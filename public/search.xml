<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[R Markdown: 数据报告生成利器]]></title>
    <url>%2F2018%2F07%2F09%2F2018-07-09-R-Markdown-%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[R Markdown 站在 knitr 和 Pandoc 的肩膀上，前者执行嵌入于文档中的计算机代码，并将 R Markdown 转换为 Markdown；后者将 Markdown 呈现出您想要的输出格式（如 PDF、HTML、Word 等） 此篇文章翻译自谢益辉新书 《R Markdown: The Definitive Guide》 的前三章节，内容有所删减，主要介绍了 R Markdown 的相关结构及语法规则，如果想了解更多更详细的内容推荐您阅读原书。 安装这里假设您已经安装了 R (https://www.r-project.org) 和 RStudio IDE (https://www.rstudio.com) 。Rstudio 并不是必须的，但安装它会使您更加容易地使用 R Markdown。如果您没有安装 RStudio IDE，您将不得不安装 Pandoc（ http://pandoc.org ），否则就不需要单独安装 Pandoc，因为在安装 RStudio 时已经将它捆绑安装了。接下来，您可以在 R 中安装 rmarkdown 包： 安装 rmarkdown 包的两种方式12345678# Install from CRANinstall.packages('rmarkdown')# Or if you want to test the development version,# install from GitHubif (!requireNamespace("devtools")) install.packages('devtools')devtools::install_github('rstudio/rmarkdown') 如果您想要生成 PDF 类型文档输出，您将需要安装 LaTeX 。对于那些以前没有安装过 LaTeX 的 R Markdown 用户，我们建议您安装 TinyTeX（https://yihui./tinytex/）： 安装 tinytex 包12install.packages("tinytex")tinytex::install_tinytex() # install TinyTeX TinyTeX 相当于一款轻量级、跨平台、易于维护的 LaTeX 。在将 LaTeX 或 R Markdown 文档编译成 PDF 时，tinytex 可以帮助您自动安装所需的相关 R 包，同时还能确保一个 LaTeX 文档被编译成正确的次数，以解决所有的交叉引用问题。如果您不明白这两件事是什么意思，应该按照我们的建议来安装 TinyTeX，因为这些细节往往并不值得您花费时间和精力去关心。 使用 rmarkdown 包、RStudio/Pandoc 和 LaTeX，您应该能够编译大多数R Markdown 文档。在某些情况下，您可能需要其他软件包，我们将在必要时提到它们。 参考文献 R Core Team. 2018. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Xie, Yihui. 2018f. Tinytex: Helper Functions to Install and Maintain Tex Live, and Compile Latex Documents. https://github.com/yihui/tinytex. 基础知识R Markdown 为数据科学提供了一个创作框架。R Markdown 能胜任以下两个任务： 保存并执行代码； 生成可共享的高质量报告。 R Markdown 的设计初衷是为了更容易地实现报告内容的可重复性，这是因为计算代码和叙述都在同一个文档中，结果是由源代码自动生成的。并且 R Markdown 支持数十种静态和动态/交互式输出格式。 如果您更喜欢观看视频进行学习，我们建议您查看网站 https://rmarkdown.rstudio.com，并在 “Get Started ” 中观看视频，其中包括了 R Markdown 的基础知识。 文档结构下面是一份非常简易的 R Markdown 文档，是一个带有 .Rmd 拓展名的纯文本文档。 YAML 元数据123456---title: "Hello R Markdown"author: "Awesome Me"date: "2018-02-14"output: html_document--- 主体内容12345678910111213This is a paragraph in an R Markdown document.Below is a code chunk:```&#123;r&#125;fit = lm(dist ~ speed, data = cars)b = coef(fit)plot(cars)abline(fit)```The slope of the regression is `r b[1]`.``` 您可以使用任何文本编辑器（包括但不限于 RStudio）来创建这样的文本文档。如果使用 RStudio，您可以从 File -&gt; New File -&gt; R Markdown 中创建一个新的 Rmd 文档。 一份 R Markdown 文档有三个基础组成部分：元数据，文本和代码。元数据是在三个连接符 --- 之间的内容。元数据的语法是 YAML（ YAML 不是标记语言 ），所以有时它也被称为 YAML metadata 或 YAML frontmatter。 需要注意的是，缩进在 YAML 中十分重要，忽视它会让你付出惨重代价。请参阅谢益辉所写的 《bookdown》（2016）一书中的 附录b.2 来了解一些简单的例子，这些示例展示了 YAML 语法。 文档的主体遵循元数据书写的规则。文本的语法是 Markdown，将在第 2.5 节中进行介绍。有两种类型的计算机代码，在第 2.6 节中进行了详细解释： 代码块：以三个重音符及所使用语言开始，其中 r 代表所使用的程序语言，并以三个重音符结束。 可以在花括号中填写块选项（如：将图形高度设置为5英寸：{r, fig.height=5}）。 内联代码：以 `r 开始，并以单个重音符结束。 文档编译最简单的方式莫过于在 RStudio 中单击 Knit 按钮，对应的快捷键为 Ctrl + Shift + K （在 macOS 中为 Cmd + Shift + K）。当然也可以直接运行代码 rmarkdown::render 来进行渲染编译，如： 文档渲染编译1rmarkdown::render('foo.Rmd', 'pdf_document') 当编译多个文档时，使用函数更加方便，因为可以直接使用循环来进行渲染编译。 参考卡片RStudio 已经创建了大量的参考卡片，它们可以在 https://www.rstudio.com/resources/cheatsheets/ 上免费获得。 输出格式有两种输出格式：documents 和 presentations 。所有可用的格式如下所示 ： beamer_presentation github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document 我们将在第 3 章和第 4 章详细地记录这些输出格式。在其他扩展包中提供了更多的输出格式（从第 5 章开始）。对于 Rmd 文件的 YAML 元数据中的输出格式名称，如果格式来自扩展包，您需要包含包名（若格式来自于 rmarkdown 包，则不需要 rmarkdown::前缀 ），例如： 输出格式设置1output: tufte::tufte_html 每种输出格式通常都有多种格式选项。所有这些选项都记录在 R 包 help 页面上。例如，您可以在 R 中键入 ?rmarkdown:: 打开关于 html_document 格式的 help 页面。当您想要使用某些选项时，必须将这些值从 R 转换成 YAML，例如： ?rmarkdown::1html_document(toc = TRUE, toc_depth = 2, dev = 'svg') 可以用 YAML 写为： 输出格式参数设置12345output: html_document: toc: true toc_depth: 2 dev: 'svg' YAML 中的字符串通常不需要引号（`dev：“svg” 和 dev:svg 是相同的），除非它们包含特殊字符，比如冒号 ：。如果您不确定是否应该引用字符串，那么用 yaml 包来测试它，例如： YAML 语法1234567cat(yaml::as.yaml(list( title = 'A Wonderful Day', subtitle = 'hygge: a quality of coziness')))## title: A Wonderful Day## subtitle: 'hygge: a quality of coziness' 注意，上面例子中的副标题是由于冒号而引用单引号的。 如果某一选项有子选项（这意味着该选项的值是 R 中的列表），则子选项需要进一步缩进，例如： 子选项-缩进123456output: html_document: toc: true includes: in_header: header.html before_body: before.html 一些选项将被传递给 knitr ，比如 dev、fig_width 和 fig_height。这些选项的详细文档可以在 knitr 文档页面 上找到。请注意，实际的 knitr 选项名称可能有所不同。特别是，knitr 在名称中使用 .，但 rmarkdown 使用 _，例如，在 rmarkdown 中，fig_width 对应于knitr 中的 fig.width 。 一些选项将被传递给 Pandoc，比如 toc、toc_depth 和 number_sections 。当有疑问时，您应该参考 Pandoc 文档。R Markdown 输出格式函数通常有一个pandoc_args 参数，它应该是传递给 Pandoc 的参数的字符向量。如果您发现任何没有由输出格式参数表示的 Pandoc 特性，您可以使用这个终极论证，例如： pandoc_args 参数1234output: pdf_document: toc: true pandoc_args: ["--wrap=none", "--top-level-division=chapter"] Markdown 语法内联格式 斜体 ：_text_ 或 *text* 粗体 ：**text** 下标 ：H~3~PO~4~ 渲染为 $H_3PO_4$ 上标 ：Cu^2+^ 渲染为 $Cu^{2+}$ 脚注 ： ^[This is a footnote.] 内联代码 ：`code` , 可以使用 n+1 个重音符输出包含 n 个重音符的代码块。 超链接 ：[text](link) 图片链接 ： ![alt text or image title](path/to/image) 引用 ： 书籍引用123456789@Manual&#123;R-base, title = &#123;R: A Language and Environment for Statistical Computing&#125;, author = &#123;&#123;R Core Team&#125;&#125;, organization = &#123;R Foundation for Statistical Computing&#125;, address = &#123;Vienna, Austria&#125;, year = &#123;2017&#125;, url = &#123;https://www.R-project.org/&#125;,&#125; 块级元素 标题 三级标题的书写12345# First-level header## Second-level header### Third-level header 如果不想让某个标题被编号，可以在标题后面添加 {-} 或者 {.unnumbered}，如： 标题不编号1# Preface &#123;-&#125; 无序列表 无序列表123456- one item- one item- one item - one more item - one more item - one more item 有序列表 有序列表123451. the first item2. the second item3. the third item - one unordered item - one unordered item 引用 名言引用12345&gt; "I thoroughly disapprove of duels. If a man should challenge me, I would take him kindly and forgivingly by the hand and lead him to a quiet place and kill him."&gt;&gt; --- Mark Twain “I thoroughly disapprove of duels. If a man should challenge me,I would take him kindly and forgivingly by the hand and lead himto a quiet place and kill him.” ​ —- Mark Twain 代码块 代码块1234567```This text is displayed verbatim / preformatted```Or indent by four spaces: This text is displayed verbatim / preformatted 数学表达式$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$ : $f(k) = {n \choose k} p^{k} (1-p)^{n-k}$ $$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$$ : f(k) = {n \choose k} p^{k} (1-p)^{n-k} 代码块选项单击 Insert 按钮，对应快捷键为 Ctrl + Alt + I （macOS：Cmd + Option + I ）。 在 https://yihui.name/knitr/options 中有大量的代码块可选项，在此我们列出常用的一部分： eval=TRUE ：执行当前代码块； eval 巧用12345678```&#123;r&#125;# execute code if the date is later than a specified daydo_it = Sys.Date() &gt; '2018-02-14'``````&#123;r, eval=do_it&#125;x = rnorm(100)``` echo=TRUE ：输出源代码； result ：当设置为 &#39;hide&#39; ，文本输出将被隐藏；当设置为 &#39;asis&#39; ，文本输出将被 “原样” 书写。 collapse=TRUE ：将文本输出和源代码合并为单个代码块输出，更加紧凑； warning, message, error ：是否在输出文档中显示警告、消息和错误； include=FALSE ：运行当前代码并且不显示任何源代码与输出结果； cache ：是否启用高速缓存。如果启用了缓存，则在下一次编译文档时不会对相同的代码块进行评估（如果代码块没有被修改），这将节省您的时间； fig.width，fig.height ：（图形设备）块的大小（英寸）。注意：fig.dim = c(6, 4) 意味着 fig.width = 6 并且 fig.height = 4； out.width， out.height ：输出文档中 R 图片的输出大小。可以使用百分比，例如 out.width = &#39;80%&#39; 表示页面宽度的 80%； fig.align ：图片的对齐方式； dev ：图形设备保存 R 图片的格式。如 &#39;pdf&#39;, &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;； fig.cap ：图片标题； child ：您可以在主文档中包含子文档。这个选项选择一条通向外部文件的路径。 如果某个选项需要经常被设置为多个代码块中的值，您可以考虑在文档的第一个代码块中全局设置它： 全局设置123```&#123;r, setup, include=FALSE&#125;knitr::opts_chunk$set(fig.width = 8, collapse = TRUE)``` 图片本地图片亦可以使用代码块选项进行调节，例如： 本地图片选项123```&#123;r, out.width='25%', fig.align='center', fig.cap='...'&#125;knitr::include_graphics('images/hex-rmarkdown.png')``` 如果您想要淡入一个不是由 R 代码生成的图形，您可以使用 knitr::include_graphics() 函数，它使您能够更好地控制图像的属性，而不是像 ![alt text or image title](path/to/image) 这样的 Markdown 语法难以调解图片属性。 表格使用 knitr::kable() 函数可以简易的创建表格，表格标题可以通过 caption 来设置，例如： 表格选项123```&#123;r tables-mtcars&#125;knitr::kable(iris[1:5, ], caption = 'A caption')``` 如果您正在寻找更高级的表格样式控制，建议您使用 kableExtra 包，它提供了定制 PDF 和 HTML 表格外观的功能。在第 12.3 节中解释了 bookdown 包如何扩展 rmarkdown 的功能，以允许在文本中轻松地交叉引用数字和表格。 参考文献 Xie, Yihui. 2015. Dynamic Documents with R and Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://yihui.name/knitr/. 输出文档HTML 文档为了输出 HTML 文档，首先要在 YAML 元数据中写入 output: html_document ： 123456---title: Habitsauthor: John Doedate: March 22, 2005output: html_document--- 目录（Table of contents）目录可选项12345678910---title: "Habits"output: html_document: toc: true toc_depth: 2 toc_float: collapsed: false smooth_scroll: false--- toc: true ：输出目录； toc_depth ：所输出标题的最小级别； toc_float: true ：目录悬停于内容左侧，并一直可见； collapsed (默认为 TRUE) ：初始只显示顶级标题，随内容滚动目录逐级展开； smooth_scroll (默认为 TRUE) ：点击目录标题是否导航到指定内容。 目录编号 (Section numbering)目录编号1234567---title: "Habits"output: html_document: toc: true number_sections: true--- 注意，如果文档中没有一级标题，那么二级标题将被命名为 0.1, 0.2 …… 选项卡 (Tabbed sections)选项卡123456789## Quarterly Results &#123;.tabset .tabset-fade .tabset-pills&#125;### By Product(tab content)### By Region(tab content) .tabset ：使主标题的所有子标题与 .tabset 属性一起出现在选项卡中，而不是作为独立的部分； .tabset-fade ：选项卡切换时淡入淡出； .tabset-pills ：改变选项卡外观，使其类似 “药丸”。 外观与风格主题与高亮1234567---title: "Habits"output: html_document: theme: united highlight: tango--- theme ：主题是从 Bootswatch 主题库中提取的，适用的主题包括：default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, 和 yeti. highlight ：代码高亮模式。支持的风格包括： default, tango, pygments, kate, monochrome, espresso, zenburn, haddock 和 textmate. 图片选项图片选项12345678---title: "Habits"output: html_document: fig_width: 7 fig_height: 6 fig_caption: true--- fig_width 和 fig_height ：图片宽度和高度； fig_caption ：控制图片是否包括标题； dev ：图片渲染格式，默认为 png。 表格打印 默认表格输出格式为： Option Description default Call the print.data.frame generic method kable Use the knitr::kable function tibble Use the tibble::print.tbl_df function paged Use rmarkdown::print.paged_df to create a pageable table 设定为 paged 格式后输出形式为： 表格设置12345678910---title: "Motor Trend Car Road Tests"output: html_document: df_print: paged---​``` &#123;r, rows.print=5&#125;mtcars​``` TABLE 3.2: The options for paged HTML tables. Option Description max.print The number of rows to print. max.print The number of rows to print. cols.print The number of columns to display. cols.min.print The minimum number of columns to display. pages.print The number of pages to display under page navigation. pages.print The number of pages to display under page navigation. rownames.print When set to FALSE turns off row names. 代码折叠代码隐藏123456---title: "Habits"output: html_document: code_folding: hide--- code_folding: hide ：初始默认不显示代码，查看者可点击进行显示； code_folding: show ：初始默认显示代码，查看者可点击进行隐藏； 高级定制保留 Markdown 文件当运行一个 R Markdown 文件（*.Rmd）时，将创造一个 Markdown 文件（*.md）并将该文件通过 Pandoc 转换为 HTML 文件。如果想要保留 Markdown 文件，可以使用 keep_md 选项： 保留 .md 文档123456---title: "Habits"output: html_document: keep_md: true--- 添加本地 HTML 文档可以通过添加额外的 HTML 内容或完全替换核心 Pandoc 模板来完成更高级的输出定制。为了在文档头部或文档主体之前/之后包含内容，您可以使用以下选项： 添加 HTML 文档123456789---title: "Habits"output: html_document: includes: in_header: header.html before_body: doc_prefix.html after_body: doc_suffix.html--- 自定义模板自定义模板123456---title: "Habits"output: html_document: template: quarterly_report.html--- 有关模板的其他详细信息，请参考 Pandoc 模板 上的文档。您还可以研究默认的 HTML 模板 default.html5 。 其他类型文档格式控制方式类似，如欲详细了解请 参考原作 。]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R Markdown</tag>
        <tag>数据报告</tag>
        <tag>可重复性</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那么长的暑假，该怎么过？]]></title>
    <url>%2F2018%2F07%2F06%2F2018-07-06-%E9%82%A3%E4%B9%88%E9%95%BF%E7%9A%84%E6%9A%91%E5%81%87%E8%AF%A5%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%BF%87%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[近两个月的暑假，如果不好好规划一番，恐怕又要让时光白白流逝掉，在这里写下暑假的个人计划，权当做个思路的整理，当然也是行动的督促了。 # 致谢 参考文章]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>随笔</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济学人-人工智能系列1]]></title>
    <url>%2F2018%2F05%2F23%2F2018-05-23-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[本文选自伦敦经济学人报纸有限公司出版的杂志 《The Economist》 MARCH 31ST–APRIL 6TH 2018 中的特别报道部分，文章总括性地介绍了人工智能技术给各行各业带来的机遇与挑战，属于人工智能专题系列报道中的第一部分。 Artificial intelligence in business GrAIt expectations | 伟大前程Artificial intelligence is spreading beyond the technology sector, with big consequences for companies, workers and consumers, says Alexandra Suich Bass 人工智能的传播已超越技术领域，给企业、员工和消费者带来了重大影响，本文作者亚历山德拉·苏伊希·巴斯观察认为 LIE DETECTORS are not widely used in business, but PingAn, a Chinese insurance company, thinks it can spot dishonesty. The company lets customers apply for loans through its app. Prospective borrowers answer questions about their income and plans for repayment by video, which monitors around 50 tiny facial expressions to determine whether they are telling the truth. The program, enabled by artificial intelligence (AI), helps pinpoint customers who require further scrutiny. 测谎仪并未在企业中得到广泛应用，但中国平安保险公司相信自己能探测谎言。这家公司让客户通过它的一款应用程序来申请贷款。预期的贷款人在视频中回答有关收入和还款计划的问题。视频会监视他们的大概50个细微面部表情，依此判断他们是否在说真话。这套由人工智能驱动的程序帮助筛查出需要进一步详细审核的客户。 AI will change more than borrowers’ bank balances. Johnson &amp; Johnson, a consumer-goods firm, and Accenture, a consultancy, use AI to sort through job applications and pick the best candidates. AI helps Caesars, a casino and hotel group, guess customers’ likely spending and offer personalised promotions to draw them in. Bloomberg, a media and financial-information firm, uses AI to scan companies’ earnings releases and automatically generate news articles. Vodafone, a mobile operator, can predict problems with its network and with users’ devices before they arise. Companies in every industry use AI to monitor cyber-security threats and other risks, such as disgruntled employees. AI 将改变的不仅仅是贷款人的账户余额。消费品公司强生（ Johnson &amp; Johnson ）和咨询公司埃森哲（ Accenture ）用 AI 查看应聘申请书，筛选出最佳人选。AI 帮助赌场和酒店集团凯撒娱乐（ Caesars ）估测客人的消费水平，提供个性化促销来吸引他们。媒体和金融信息公司彭博（ Bloomberg ）用 AI 扫描企业财报，自动生成新闻报道。移动运营商沃达丰（ Vodafone ）用 AI 监测其网络和用户设备，提前预警故障。各行各业的公司都在使用 AI 监控网络安全威胁和其他风险，比如心怀不满的员工。 Instead of relying on gut instinct and rough estimates, cleverer and speedier AI-powered predictions promise to make businesses much more efficient. At Leroy Merlin, a French home-improvement retailer, managers used to order new stock on Fridays, but defaulted to the same items as the week before so they could start their weekend sooner. The firm now uses algorithms to take in past sales data and other information that could affect sales, such as weather forecasts, in order to stock shelves more effectively. That has helped it reduce its inventory by 8% even as sales have risen by 2%, says Manuel Davy of Vekia, the AI startup that engineered the program. 相比依赖直觉和粗略的估算，更聪明也更快速的 AI 预测将帮助企业大幅提高效率。法国家居装饰零售商乐华梅兰（ Leroy Merlin ）的管理层以前每周五下新订单，默认的设置是重复前一周的订单，这样大家可以早点下班过周末。现在，公司用算法来斟酌历史销售数据和天气预报等其他可能影响销售的信息，以更有效地安排库存。按创建该算法的 AI 创业公司 Vekia 的曼纽尔·戴维说，这帮助该公司将库存减少了8%，同时销售额却增长了2%。 AI and machine learning (terms that are often used interchangeably) involve computers crunchingvast quantities ofdata to find patterns and make predictions without being explicitly programmed to do so. Larger quantities of data, more sophisticated algorithms and sheer computing power have given AI greater force and capability. The outcomes are often similar to what an army of statisticians with unlimited time and resources might have come up with, but they are achieved far more quickly, cheaply and efficiently. AI 和机器学习（这两个术语常被混用）用计算机处理查看海量数据，从中找出模式并做出预测，而不需要编程来作出明确的指示。更多数据、更复杂的算法和更高的计算能力已经赋予了 AI 更强大的能力。它得出的结果往往和一大批拥有无限时间和资源的统计师所得的差不多，但它远为快速、便宜和高效。 One of AI’s main effects will be a dramatic drop in the cost of making predictions, says Ajay Agrawal of the University of Toronto and co-author of a new book, “Prediction Machines”. Just as electricity made lighting much more affordable—a given level of lighting now costs around 400 times less than it did in 1800—so AI will make forecasting more affordable, reliable and widely available. AI 的主要成果之一是将令预测的成本大幅下降，新书《预测机器》的合著者、多伦多大学的阿杰伊·阿格拉沃尔表示。就像电力让照明成本比 1800 年时降低了 400 倍左右——AI 会让做预测更便宜、更可靠、更普及。 Computers have been able to read text and numbers for decades, but have only recently learned to see, hear and speak. AI is an omnibus term for a “salad bowl” of different segments and disciplines, says Fei-Fei Li, director of Stanford’s AI Lab and an executive at Google’s cloud-computing unit. Subsections of AI include robotics, which is changing factories and assembly lines, and computer vision, used in applications from identifying something or someone in a photo to self-driving-car technology. Computer vision is AI’s “killer app”, saysMs Li, because it can be used in so many settings, but AI has also become more adept at recognising speech. It underlies voice assistants on phones and home speakers and allows algorithms to listen to calls and take in the speaker’s tone and content. 计算机几十年前就已经可以阅读文本和数字了，但直到最近才学会了看、听、说。AI 是一个综合性术语，就像是涵盖了不同领域和学科的“一碗色拉”，斯坦福大学人工智能实验室主管、谷歌云计算部门负责人李飞飞说。AI 的下属分支包括正在改变工厂和装配线的机器人技术，以及部署在各种应用程序中的计算机视觉——从识别照片中的人或物到无人驾驶汽车技术等。李飞飞说，计算机视觉是 AI 的“杀手级应用”，因为运用场合是如此之多，但 AI 在语音识别方面也已变得更加娴熟。它在配备在手机和家用音响上的语音助理的技术基础，还让算法能够监听来电并识别说话者的语调和内容。 Techtonic shifts | 技术板块迁移Until now the main beneficiary of AI has been the technology sector. Most of today’s leading tech firms, such as Google and Amazon in the West and Alibaba and Baidu in China, would not be as big and successful without AI for product recommendations, targeted advertising and forecasting demand. Amazon, for example, uses AI widely, for tasks such as guiding robots in its warehouses and optimising packing and delivery, as well as detecting counterfeit goods and powering its speaker, Alexa. Alibaba, a Chinese rival, also makes extensive use of AI, for example in logistics; and its online-payments affiliate, Ant Financial, is experimenting with facial recognition for approving transactions. Sundar Pichai, Google’s boss, has said that AI will have a “more profound” impact than electricity or fire. 到目前为止，AI 的主要受益者一直是技术部门。若果没有 AI 帮助实现产品推荐、定向广告和需求预测，那么当今大多数科技领军企业，比如西方的谷歌和亚马逊以及中国的阿里巴巴和百度，都不会发展到今天这般庞大且成功。举例来说，亚马逊广泛使用 AI 来完成各种任务，诸如在仓库中指示机器人工作、优化包装和运送、检测假货，支持其智能音箱 Alexa 等。它的竞争对手，中国的阿里巴巴也在物流等部门广泛运用 AI，其在线支付分支机构蚂蚁金服正测试使用面部识别来核准交易。谷歌执行长桑达尔·皮查伊曾经说过，AI 将产生比电或火“更深远”的影响。 Bosses of non-tech companies in a broad range of industries are starting to worry that AI could scorch or even incinerate them, and have been buying up promising young tech firms to ensure they do not fall behind. In 2017 firms worldwide spent around \$21.8bn on mergers and acquisitions related to AI, according to PitchBook, a data provider, about 26 times more than in 2015 (see chart). They are doing this partly to secure talent, which is thin on the ground. Startups without revenue are fetching prices that amount to \$5m-10m per AI expert. 然而各行各业的非科技公司老板们已经开始担心，AI 可能会冲击甚至毁灭自己，因而他们纷纷收购看起来颇有前途的年轻科技公司，以确保自己不落人后。据数据供应商 PitchBook 统计，2017 年全球企业在 AI 相关并购上的支出约达 218 亿美元，比 2015 年增长约 26 倍（见图表）。它们这样做的部分原因是为获得目前仍相当稀缺的 AI 人才。尚未产生收入的创业公司为聘请一名 AI 专家花费多达 500 万至 1000 万美元。 As AI spreads beyond the tech sector, it will fuel the rise of new firms that challenge incumbents. This is already happening in the car industry, with autonomous-vehicle startups and ride-hailing firms such as Uber. But it will also change the way other companies work, transforming traditional functions such as supply-chain management, customer service and recruitment. 随着 AI 传播到科技行业之外，它将推动新企业的崛起，为成熟企业带来挑战。这已经在汽车产业里发生——AI 催生了无人驾驶汽车创业公司和优步等网约车公司。但它也将改变其他企业的运作方式，改变供应链管理、客服和招聘等传统职能。 The path ahead is exhilarating but perilous. Around 85% of companies think AI will offer a competitive advantage, but only one in 20 is “extensively” employing it today, according to a report by MIT’s SloanManagement Review and the Boston Consulting Group. Large companies and industries, such as finance, that generate a lot of data, tend to be ahead and often build their own AI-enhanced systems. But many firms will choose to work with the growing array of independent AI vendors, including cloud providers, consultants and startups. 前路令人振奋却也危险重重。根据麻省理工学院的《斯隆管理评论》和波士顿咨询集团联合撰写的报告，约 85% 的企业认为 AI 将带来竞争优势，但只有 5% 的公司正在“广泛”地使用它。生成大量数据的大企业和金融等行业往往走在前头，常常建立自己的 AI 增强系统。但许多企业会选择与队伍不断扩大的独立 AI 供应商合作，包括云供应商、咨询公司和创业公司等。 This is not just a corporate race but an international one, too, especially between America and China. Chinese firms have an early edge, not least because the government keeps a vast database of faces that can help train facial-recognition algorithms; and privacy is less of a concern than in the West. 这不仅是一项企业竞赛，也是一场国际竞逐——尤其在中美之间。中国企业有一个先发优势，这主要是因为中国政府拥有一个庞大的人脸数据库，可以用来训练面部识别算法。而且，与西方相比，中国人对隐私也不那么关切。 There will be plenty of opportunities to stumble. One difficult issue for companies will be timing. Roy Bahat of Bloomberg Beta, a venture-capital firm, draws a parallel between now and the first dotcom boom of the late 1990s: “Companies are flailing to figure out what to spend money on.” If they invest huge sums in AI early on, they run the risk of overcommitting themselves or paying large amounts for worthless startups, as many did in the early days of the internet. But if they wait too long, they may leave themselves open to disruption from upstarts, as well as from rivals that were quicker to harness technology. 跌跤的机会很多。企业面临的难题之一是对时机的把握。风险投资公司 Bloomberg Beta 的罗伊·巴哈特把眼下的状况比作上世纪 90 年代末的首个互联网泡沫期：“对于该往哪儿投钱，企业无所适从。”如果它们早早地在 AI 上投入巨资，就要冒对一文不值的创业公司过度依赖或为之浪费大笔金钱的风险，就像互联网早期许多公司的经历那样。但如果它们等得太久，又有可能把自己置于被市场新贵颠覆的境地，还可能被更快掌握了新技术的竞争对手冲击。 Some may have been misled by glowing media reports, believing AI to be a magic wand that can be installed as easily as a piece of Microsoft software, says Gautam Schroff of Tata Consultancy Services, an Indian firm. AI systems require thorough preparation of data, intensive monitoring of algorithms and a lot of customisation to be useful. Gurdeep Singh of Microsoft speaks of AI systems as “idiots savants”; they can easily do jobs that humans find mind-boggling, such as detecting tiny flaws in manufactured goods or quickly categorising millions of photos of faces, but have trouble with things that people find easy, such as basic reasoning. Back in 1956, when academic researchers held their first gathering to discuss AI, they were looking for a way to imbue machines with human-like “general” intelligence, including complex reasoning. But that remains a distant aspiration. 还有些企业可能被媒体天花乱坠的报道误导，以为 AI 就是一根魔法棒，像微软的软件一样容易安装，印度公司塔塔咨询服务的高塔姆·施罗夫说。AI 系统需要全面细致地准备数据、深入地监测算法和大量的定制才能发挥用处。微软的格迪普·辛格称 AI 系统为“白痴专家”——它们能轻易完成让人类望而却步的艰巨任务，比如检测制成品中的细小瑕疵，或给数百万人脸照片快速分类，但在那些对人类而言轻而易举的任务上（比如基础推理）却遇到麻烦。早在 1956 年学术研究人员举行首次 AI 研讨会时，他们就在寻找办法来赋予机器像人类那样的“一般”智能，包括复杂推理的能力。但直到今天，这仍是一种遥遥无期的向往。 The excitement around AI has made it hard to separate hype from reality. In the last quarter of 2017 public companies across the world mentioned AI and machine learning in their earnings reports more than 700 times, seven times as often as in the same period in 2015 (see chart). There are so many firms peddling AI capabilities of unproven value that someone should start “an AI fake news” channel, quips Tom Siebel, a Silicon Valley veteran. AI 引发的兴奋之情使得我们难以分辨炒作和现实。2017 年最后一个季度，全球上市公司在它们的财报中提到 AI 和机器学习多达 700 多次，是 2015 年同期的七倍（见图表）。硅谷资深人士汤姆·西贝尔开玩笑说，这么多公司在兜售尚未证实价值的 AI 技术，应该有人来开办一个“AI 假新闻”频道了。 Bosses must keep several time horizons in mind. In the near future AI will reshape traditional business functions such as finance, HR and customer service, according to Michael Chui of the McKinsey Global Institute, a think-tank within a consultancy. But over time it will also disrupt whole industries, for example by powering the rise of autonomous vehicles or the discovery of entirely new drug combinations. Where as humans may have preconceptions about which product designs or drug combinations are likely to work best, algorithms are more likely to come up with novel solutions. 老板们必须记住几个时间跨度。根据咨询公司麦肯锡下属智库麦肯锡全球研究所的迈克尔·崔的说法，在不久的将来，人工智能将重塑传统的商业功能，如金融、人力资源和客户服务。但随着时间的推移，它也将颠覆行业整体，比如通过推动无人驾驶汽车兴起和发现全新的药物组合等。人类对于哪种产品设计或药物组合可能取得最佳效果也许已有成见，而算法更可能提出新的解决方案。 In private, many bosses are more interested in the potential cost and labour savings than in the broader opportunities AI might bring, says John Hagel of Deloitte, a consultancy. That is certainly not good for workers, but nor, ultimately, is it good for business. “If you just cut costs and don’t increase value for customers, you’re going to be out of the game,” he says. Some companies may not actually eliminate existing jobs but use technology to avoid creating new ones. And workers who keep their jobs are more likely to feel spied on by their employers. Some firms already use AI to comb through their workers’ communications to ensure that they are not breaking the law. Such practices will spread, raising privacy issues. 咨询公司德勤的约翰·哈格尔表示，私下里，许多企业老板更为关注 AI 能帮助节省多少成本和劳动力，而不是它可能带来的更广泛机遇。这对工人来说当然不是好事，但最终也会对企业不利。他表示：“如果你只是削减成本，而不增加为客户带来的价值，那你就会出局。”一些公司实际上或许并不会削减现有岗位，但会利用技术来避免增员。而那些保住了工作的工人更可能感到被雇主暗中监视。一些公司已经在使用 AI 查看员工的聊天记录，以确保他们不违法。这类做法将日益普遍，从而引发隐私问题。 A longer-term concern is the way AI creates a virtuous circle or “fly wheel” effect, allowing companies that embrace it to operate more efficiently, generate more data, improve their services, attract more customers and offer lower prices. That sounds like a good thing, but it could also lead to more corporate concentration and monopoly power—as has already happened in the technology sector. 从更长远的视角来看，人工智能创造了一个良性循环或“飞轮”效应，允许接受它的公司更有效地运作，产生更多的数据，改善服务，吸引更多的客户，并提供更低的价格。这听起来像是一件好事，但它也可能导致更多的企业集中度和垄断权力——就像科技行业已经发生的那样。 Related Articles | 相关文章 How AI can make businesses look more caring ? AI is making companies swifter, cleverer and leaner. AI with mainly be good for business, but mind the pitfalls. AI is changing the way firms screen, hire and manage their talent. AI will make workplaces more efficient, safer — and much creepier. A thriving ecosystem has sprung up to offer AI expertise and technical help.]]></content>
      <categories>
        <category>经济学人</category>
      </categories>
      <tags>
        <tag>经济学人</tag>
        <tag>人工智能</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化-R绘图包系列]]></title>
    <url>%2F2018%2F04%2F07%2F2018-04-07-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-R%E7%BB%98%E5%9B%BE%E5%8C%85%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[R 中有四大框架用于产生静态图形: graphics、grid、lattice、ggplot2， 利用这些包可以将结构或非结构数据转换成适当的可视化图表，展现出隐藏在数据中的信息 此系列文章主要介绍 R 基础绘图命令，涵盖 graphics、grid、lattice、ggplot2 等包，欢迎阅读。 文章列表： graphics：R 基础绘图包-par() graphics：R 基础绘图包-plot() grid: 网格图形 待写 lattice：条件作图 待写 ggplot2：图层作图 待写 …………]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>graphics</tag>
        <tag>grid</tag>
        <tag>lattice</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化 - 地图可视化系列文章]]></title>
    <url>%2F2018%2F04%2F05%2F2018-04-05-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[可视化的形式也五彩缤纷，星现多维化的局面，并正在发展，地图可视化是空间信息可视化的最主要形式，这种数据表达方式让人一目了然，方便挖掘深层信息，更好的辅助决策 此系列文章主要介绍地图类 API 的使用以及诸多地图可视化包的使用。 文章列表： REmap + BaidumapAPI：交互式地图 百度地图 API 那些事 待写 …………]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>API</tag>
        <tag>REmap</tag>
        <tag>地图可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DT：DataTables 库的 R 接口]]></title>
    <url>%2F2018%2F04%2F05%2F2018-04-05-DT-DataTables%E5%BA%93%E7%9A%84R%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[R 包 DT 为 JavaScript 的 DataTable 库提供了一个 R 接口。R 对象（矩阵或数据框）可在 HTML 页面上显示为表格，DataTable 在表格中提供过滤，分页，排序和许多其他功能。 此文章翻译自 DT包官方文档，十分感谢谢益辉大神提供了如此方便的 HTML 页面数据表展现包。 译文列表： DT：DataTables 库的 R 接口]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>DT</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化-formattable包]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-formattable%E5%8C%85%2F</url>
    <content type="text"><![CDATA[该软件包使用预定义的格式化规则更加丰富形象地展示数据， 在存储原始数据的同时将输出结果用格式化输出，使数据在保留原有属性的基础上更加易读 加载包这个包的功能很简单，但是却很具创意性，它颠覆了 R 语言数据以及数据表的呈现方式，数据方面提供了百分数、会计技术等多个 R 尚未支持的数据格式；数据表方面支持自定义视觉化元素，如对某一列数据进行字号、颜色、背景、以及图形化处理，整体的版式仍然保留表格的样式，但是已经具有了表和图结合的意味。 首先加载所需的程序包：安装formattable包123devtools::install_github("renkun-ken/formattable")install.packages("formattable")library("formattable") 格式化数据该包提供了几个典型的可格式化对象，它们包括：percent, comma, currency, accounting 和 scientific 。这些对象实质上是具有预定义格式规则和参数的数值型向量。 percentpercent-函数定义：将输出向量自定义为百分比数字格式1234567percent(x, digits = 2L, format = "f", ...)## Default S3 method:percent(x, digits = 2L, format = "f", ...)## S3 method for class 'character'percent(x, digits = NA, format = "f", ...) 参数列表：x：数值型向量digits：一个整数，用于指示百分比字符串的位数format：格式类型，传递给formatC Examples-函数使用123456789101112p &lt;- percent(c(0.1, 0.02, 0.03, 0.12))p&gt; # 函数保留了保留其数学运算属性&gt; p + 0.05[1] 15.00% 7.00% 8.00% 17.00%&gt; mean(p)[1] 6.75%&gt; # formattable格式继承了numeric属性，因而保留了数学运算能力&gt; class(p)[1] "formattable" "numeric" commacomma-函数定义：将输出向量自定义为千位分隔符数字格式12345678comma(x, digits, format = "f", big.mark = ",", ...)## Default S3 method:comma(x, digits = 2L, format = "f", big.mark = ",", ...)## S3 method for class 'character'comma(x, digits = max(get_digits(x)), format = "f", big.mark = ",", ...) 参数列表：x：数值型向量digits：一个整数，用于指示百分比字符串的位数format：格式类型，传递给formatC Examples-函数使用12345678&gt; comma(1000000)[1] 1,000,000.00&gt; comma(c(1250000, 225000))[1] 1,250,000.00 225,000.00 &gt; comma(c(1250000, 225000), format = "d")[1] 1,250,000 225,000 &gt; comma("123,345.123")[1] 123,345.123 currencycurrency-函数定义：将输出向量自定义为百分比数字格式123456789currency(x, symbol, digits, format = "f", big.mark = ",", ..., sep = "")## Default S3 method:currency(x, symbol = "$", digits = 2L, format = "f", big.mark = ",", ..., sep = "")## S3 method for class 'character'currency(x, symbol = get_currency_symbol(x), digits = max(get_digits(x)), format = "f", big.mark = ",", ...) 参数列表：x：数值型向量symbol：货币符号digits：一个整数，用于指示百分比字符串的位数format：格式类型，传递给formatCbig.mark：千分隔符sep：符号和值之间的分隔符 Examples-函数使用12345678&gt; currency(200000)[1] $200,000.00&gt; currency(1200000, "USD", format = "d", sep = " ")[1] USD 1,200,000&gt; currency("$ 120,250.50")[1] $120,250.50&gt; currency("HK$ 120, 250.50")[1] HK$120,250.50 accountingaccounting-函数定义：将输出向量自定义为会计数字格式123456789accounting(x, digits = 2L, format = "f", big.mark = ",", ...)## Default S3 method:accounting(x, digits = 2L, format = "f", big.mark = ",", ...)## S3 method for class 'character'accounting(x, digits = max(get_digits(x)), format = "f", big.mark = ",", ...) 参数列表：x：数值型向量digits：一个整数，用于指示小数位数format：格式类型，传递给formatCbig.mark：千分隔符 Examples-函数使用12345678910&gt; # 两位小数，同时负值加括号&gt; balance &lt;- accounting(c(1000, 500, 200, -150, 0, 1200))&gt; balance[1] 1,000.00 500.00 200.00 (150.00) 0.00 1,200.00&gt; accounting(c(1200, -3500, 2600), format = "d")[1] 1,200 (3,500) 2,600 &gt; # 函数保留了保留其数学运算属性&gt; balance + 1000[1] 2,000.00 1,500.00 1,200.00 850.00 1,000.00 2,200.00 scientificscientific-函数定义：1scientific(x, format = c("e", "E"), digits = 4, ...) 参数列表：x：数值型向量digits：一个整数，用于指示小数位数format：格式类型，传递给formatC Examples-函数使用1234&gt; scientific(1253421, digits = 8)[1] 1.25342100e+06&gt; scientific(1253421, digits = 8, format = "E")[1] 1.25342100E+06 复杂数据结构formattable() 将高度可定制的格式应用于各种类的对象，如 numeric, logical, factor, Date, data.frame 等。例如，数据框可能也可存储格式化的列向量（这是自然地，因为数据框就是由若干个等长的向量组成的）： 数据框数据格式化12345678910111213&gt; df &lt;- data.frame(+ id = c(1, 2, 3, 4, 5), + name = c("A1", "A2", "B1", "B2", "C1"),+ balance = accounting(c(52500, 36150, 25000, 18300, 7600), format = "d"),+ growth = percent(c(0.3, 0.3, 0.1, 0.15, 0.15), format = "d"),+ ready = formattable(c(TRUE, TRUE, FALSE, FALSE, TRUE), "yes", "no"))&gt; df id name balance growth ready1 1 A1 52,500 30% yes2 2 A2 36,150 30% yes3 3 B1 25,000 10% no4 4 B2 18,300 15% no5 5 C1 7,600 15% yes 格式化数据表举个栗子普通的表格数据如下所示：普通表格1234567891011121314151617181920212223&gt; df &lt;- data.frame(+ id = 1:10,+ name = c("Bob", "Ashley", "James", "David", "Jenny", + "Hans", "Leo", "John", "Emily", "Lee"), + age = c(28, 27, 30, 28, 29, 29, 27, 27, 31, 30),+ grade = c("C", "A", "A", "C", "B", "B", "B", "A", "C", "C"),+ test1_score = c(8.9, 9.5, 9.6, 8.9, 9.1, 9.3, 9.3, 9.9, 8.5, 8.6),+ test2_score = c(9.1, 9.1, 9.2, 9.1, 8.9, 8.5, 9.2, 9.3, 9.1, 8.8),+ final_score = c(9, 9.3, 9.4, 9, 9, 8.9, 9.25, 9.6, 8.8, 8.7),+ registered = c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE),+ stringsAsFactors = FALSE)&gt; df id name age grade test1_score test2_score final_score registered1 1 Bob 28 C 8.9 9.1 9.00 TRUE2 2 Ashley 27 A 9.5 9.1 9.30 FALSE3 3 James 30 A 9.6 9.2 9.40 TRUE4 4 David 28 C 8.9 9.1 9.00 FALSE5 5 Jenny 29 B 9.1 8.9 9.00 TRUE6 6 Hans 29 B 9.3 8.5 8.90 TRUE7 7 Leo 27 B 9.3 9.2 9.25 TRUE8 8 John 27 A 9.9 9.3 9.60 FALSE9 9 Emily 31 C 8.5 9.1 8.80 FALSE10 10 Lee 30 C 8.6 8.8 8.70 FALSE 格式化表格，具有以下可视化效果：格式化表格1234567891011121314151617181920&gt; formattable(df, + list(+ age = color_tile("white", "orange"),+ grade = formatter(+ "span", + style = x ~ ifelse(x == "A", style(color = "green", font.weight = "bold"), NA)+ ),+ area(col = c(test1_score, test2_score)) ~ normalize_bar("pink", 0.2),+ final_score = formatter(+ "span",+ style = x ~ style(color = ifelse(rank(-x) &lt;= 3, "green", "gray")),+ x ~ sprintf("%.2f (rank: %02d)", x, rank(-x))+ ),+ registered = formatter(+ "span",+ style = x ~ style(color = ifelse(x, "green", "red")),+ x ~ icontext(ifelse(x, "ok", "remove"), ifelse(x, "Yes", "No"))+ )+ )+ ) 表格中使用的图标集由GLYPHICONS.com提供并包含在Bootstrap中。 注意到一共用了 文字格式自定义、文字背景自定义、文本自定义 三种自定义可视化类型： color_tile函数用于输出按照数值量级进行颜色背景填充的列。 formatter函数提供字体显示格式的自定义，grade列自定义了值为A的记录显示绿色，并将字体加粗，否则忽略。test1_score, test2_score两列通过area函数在对应字体背景位置使用条形图来代表指标量级大小，颜色填充粉色。final_score列对指标按照top3显示绿色，其余显示灰色，同时将内容显示格式自定义为浮点型+(rank:名次)进行显示。registered列则在对填充颜色按照对应布尔值进行显示（TRUE显示绿色、FALSE显示红色）之外，在左侧添加了对用的icon文本（TRUE显示绿色对号，FALSE显示红色叉号）。 文字格式自定义color_texteg-color_text("color1", "color2")：输出按照数值量级进行字体颜色填充的列1formattable(mtcars, list(mpg = color_text("black", "red"))) formatterformatter-函数定义：创建一个HTML元素制作的格式化函数1formatter(.tag, style = ...) 参数列表：.tag：HTML 标签，默认为 spanstyle：CSS语句注：类似 x ~ expr 的公式将表现得像 function(x) expr 诸多CSS样式于此可见：List of CSS properties 文字背景自定义色块函数色块函数12345678910111213# color_tile("color1", "color2")# 输出按照数值量级进行颜色背景填充的列formattable(mtcars, list(mpg = color_tile("white", "pink")))# color_bar(color = "lightgray", fun = "proportion", ...)# 输出有颜色填充的，大小以数值量级为比例的色块formattable(mtcars, list(mpg = color_bar("lightgray", proportion)))# normalize_bar(color = "lightgray", ...)# proportion_bar(color = "lightgray", ...)# 按正常配置输出大小以数值量级为比例的色块formattable(mtcars, list(mpg = normalize_bar()))formattable(mtcars, list(mpg = proportion_bar())) areaarea-函数定义：选取特定表格区域进行格式化1area(row, col) ~ formatter/normalize_bar…… 参数列表：row/col：选取的行与列，默认为全选 文本自定义icontexticontext-函数定义：文本修饰函数-添加图标、更改内容1icontext(icon, text = list(NULL), ...) 参数列表：icon：图标名称的字符矢量或字符矢量列表text：文本的字符向量 使用的图标集由GLYPHICONS.com提供并包含在Bootstrap中。 致谢 参考文章 Github：任坤的formattable项目 杜雨：一款脑洞大开的表格可视化神器]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>formattable</tag>
        <tag>数据展示</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作-apply函数族]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C-apply%E5%87%BD%E6%95%B0%E6%97%8F%2F</url>
    <content type="text"><![CDATA[R 作为一种向量化的编程语言，一大特征便是以向量计算替代了循环计算，使效率大大提升。 apply函数族正是为解决数据循环处理问题而生的 —— 面向不同数据类型，生成不同返回值的包含8个相关函数的函数族。 为何要用apply？在使用 R 时，要尽量用 array 的方式思考，避免 for 循环，写过多的 for 循环代码，最后把 R 代码写的跟 C 似得说明你没有进入 R 的思考方式，是一种费力不讨好的行为。那么不用循环怎么实现迭代呢？apply函数族是一把利器，它不是一个函数，而是一族功能类似的函数。 语法详解applyapply-函数定义：在 X 上，沿 margin 方向，依次调用 FUN1apply(X, margin, FUN, ...) 参数列表：X：数组、矩阵、数据框margin：按维度运算，1表示按行，2表示按列，c(1,3)表示第1、3维FUN：要使用的函数 举例阐释 eg1-矩阵按列求和123456789&gt; mat &lt;- matrix(1:12, 3, 4)&gt; mat [,1] [,2] [,3] [,4][1,] 1 4 7 10[2,] 2 5 8 11[3,] 3 6 9 12&gt; apply(mat, 2, sum)[1] 6 15 24 33 eg2-数组第1、3维度组合求和123456789101112131415&gt; ary &lt;- array(1:12, c(2,3,2))&gt; ary, , 1 [,1] [,2] [,3][1,] 1 3 5[2,] 2 4 6, , 2 [,1] [,2] [,3][1,] 7 9 11[2,] 8 10 12&gt; apply(ary, c(1,3), sum) [,1] [,2][1,] 9 27[2,] 12 30 eg3-数据框按列求均值123456789101112&gt; data &lt;- data.frame(x1=1:5, x2=6:10)&gt; data x1 x21 1 62 2 73 3 84 4 95 5 10&gt; apply(data, 2, mean)x1 x2 3 8 tapplytapply-函数定义：按 INDEX 值分组，相同值对应下标的 X 中的元素形成一个集合，应用到 FUN1tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE) 参数列表：X：向量、数组INDEX：用于分组的索引FUN：要使用的函数simplify : 是否数组化，当值TRUE时，输出结果按数组进行分组输出 举例阐释 eg1-当FUN为NULL，返回分组的结果，返回值中相等的元素所对应的下标属于同一组1234&gt; x &lt;- 1:6&gt; INDEX &lt;- c('a','a','b','c','c','c')&gt; tapply(x, INDEX)[1] 1 1 2 3 3 3 eg2-向量按 INDEX 分组求和123&gt; tapply(x, INDEX, sum) a b c 3 3 15 eg3-矩阵按 INDEX 分组求均值123456789101112131415&gt; mat &lt;- matrix(1:10, 2)&gt; mat [,1] [,2] [,3] [,4] [,5][1,] 1 3 5 7 9[2,] 2 4 6 8 10&gt; INDEX &lt;- matrix(c(rep(1,5), rep(2,5)), nrow=2)&gt; INDEX [,1] [,2] [,3] [,4] [,5][1,] 1 1 1 2 2[2,] 1 1 2 2 2&gt; tapply(mat, INDEX) [1] 1 1 1 1 1 2 2 2 2 2&gt; tapply(mat, INDEX, mean)1 2 3 8 lapplylapply-函数定义：在 X 上逐个元素调用 FUN, 返回和 X 等长的 list 作为结果集1lapply(X, FUN, ...) 参数列表：X：列表、向量、数据框FUN：要使用的函数 举例阐释 eg1-计算 list 中的每个 KEY 对应数据的均值12345678910111213141516&gt; lst &lt;- list(a=1:10, b=seq(0,7,2), c=c(2,5,8))&gt; lst$a [1] 1 2 3 4 5 6 7 8 9 10$b[1] 0 2 4 6$c[1] 2 5 8&gt; lapply(lst, mean)$a[1] 5.5$b[1] 3$c[1] 5 eg2-对数据框的列求和12345678910111213&gt; data &lt;- data.frame(x1=1:5, x2=6:10)&gt; data x1 x21 1 62 2 73 3 84 4 95 5 10&gt; lapply(data, sum)$x1[1] 15$x2[1] 40 eg3-找出闰年：对向量内各元素依次调用函数1234567&gt; isLeapYear &lt;- function(a)&#123;+ if( (a%%4==0 &amp; a%/%100!=0) | a%%400==0 )+ a+ &#125;&gt; a &lt;- 1900:1910&gt; unlist(lapply(a, isLeapYear))[1] 1900 1904 1908 rapplyrapply-函数定义：递归版lapply，对list遍历直至无list，最终非list元素若类型是classes参数指定的类型，则调用FUN1rapply(list, f, classes = "ANY", deflt = NULL,how = c("unlist", "replace", "list"), ...) 参数列表：list：列表f：要使用的函数classes： 匹配类型, ANY为所有类型deflt: 非匹配类型的默认值how: 3种操作方式， replace：则用调用f后的结果替换原list中原来的元素； list：新建一个list，类型匹配调用f函数，不匹配赋值为deflt； unlist：执行一次unlist(recursive = TRUE)操作 举例阐释 eg1-遍历 list 分组求和123456789101112131415161718192021222324&gt; lst &lt;- list(a=list(aa=c(1:5), ab=c(6:10)), b=list(ba=c(1:10)))&gt; lst$a$a$aa[1] 1 2 3 4 5$a$ab[1] 6 7 8 9 10$b$b$ba [1] 1 2 3 4 5 6 7 8 9 10&gt; rapply(lst, sum, how="replace") # 输出结果为list$a$a$aa[1] 15$a$ab[1] 40$b$b$ba[1] 55&gt; rapply(lst, sum, how="unlist") # 输出结果为vectora.aa a.ab b.ba 15 40 55 sapplysapply-函数定义：简化版lapply，增加参数simplify和USE.NAMES，可设定输出类型1sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 参数列表：X：列表、向量、数据框FUN：要使用的函数simplify: 若FALSE，等价于lapply。否则，将lapply输出的list简化为vector或matrixUSE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 举例阐释 eg1-simplify参数设定输出类型123456789101112131415161718&gt; lst &lt;- list(a=c(1:5), b=c(6:10))&gt; sapply(lst, sum, simplify = F) # 输出list$a[1] 15$b[1] 40&gt; sapply(lst, sum) # 输出vector a b 15 40 &gt; sapply(lst, fivenum) # 输出matrix a b[1,] 1 6[2,] 2 7[3,] 3 8[4,] 4 9[5,] 5 10 eg2-USE.NAMES参数作用12345678&gt; val &lt;- head(letters)&gt; val[1] "a" "b" "c" "d" "e" "f"&gt; sapply(val, paste) a b c d e f "a" "b" "c" "d" "e" "f" &gt; sapply(val, paste, USE.NAMES = F)[1] "a" "b" "c" "d" "e" "f" vapplyvapply-函数定义：类似sapply，但提供参数FUN.VALUE用以设定返回值的行名1vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) 参数列表：X：列表、数据框FUN：要使用的函数FUN.VALUE：定义返回值的行名row.namesUSE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 举例阐释 eg1-FUN.VALUE参数设置返回值行名123456&gt; lst &lt;- list(a=c(1:5), b=c(6:10))&gt; res &lt;- vapply(lst, function(x) c(min(x), max(x)), c(min.=0, max.=0))&gt; res a bmin. 1 6max. 5 10 eg2-对数据框的数据累计求和，并对每一行设置行名row.names1234567891011121314&gt; data &lt;- data.frame(cbind(x1=3, x2=c(2:1,4:5)))&gt; data x1 x21 3 22 3 13 3 44 3 5&gt; vapply(data, cumsum, FUN.VALUE=c('a'=0,'b'=0,'c'=0,'d'=0)) x1 x2a 3 2b 6 3c 9 7d 12 12 mapplymapply-函数定义：多变量版sapply，将FUN应用于多个同结构数据第一个元素组成的数组，然后是第二个元素组成的数组，依此类推1mapply(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE, USE.NAMES=TRUE) 参数列表：FUN：要使用的函数…: 接收多个数据(list、vector)MoreArgs: FUN的参数列表simplify: 若FALSE，输出list。否则，将输出的list简化为vector或matrixUSE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 举例阐释 eg1-输入两个list并分组求和123&gt; mapply(sum, list(a=1,b=2,c=3), list(a=10,b=20,d=30)) a b c 11 22 33 eg2-比较两个向量大小，按索引顺序取较大的值12345678&gt; a &lt;- 1:10&gt; b &lt;- 5:-4&gt; a [1] 1 2 3 4 5 6 7 8 9 10&gt; b [1] 5 4 3 2 1 0 -1 -2 -3 -4&gt; mapply(max, a, b) [1] 5 4 3 4 5 6 7 8 9 10 eg3-输入向量，返回值多个时返回matrix12345&gt; mapply(function(x,y) c(x+y, x^y, x-y), c(1:5), c(1:5)) [,1] [,2] [,3] [,4] [,5][1,] 2 4 6 8 10[2,] 1 4 27 256 3125[3,] 0 0 0 0 0 eapplyeapply-函数定义：对一个环境空间中的所有变量进行遍历1eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE) 参数列表：env: 环境空间FUN：要使用的函数all.names: 匹配类型, ANY为所有类型USE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 举例阐释 eg-eapply操作示例123456789101112131415161718192021&gt; # 定义一个环境空间&gt; env &lt;- new.env()&gt; # 向这个环境空间中存入3个变量&gt; env$a &lt;- 1:10&gt; env$b &lt;- exp(-3:3)&gt; env$logic &lt;- c(TRUE, FALSE, FALSE, TRUE)&gt; ls(env) # 查看env空间中的变量[1] "a" "b" "logic"&gt; ls.str(env) # 查看env空间中的变量字符串结构a : int [1:10] 1 2 3 4 5 6 7 8 9 10b : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...logic : logi [1:4] TRUE FALSE FALSE TRUE&gt; eapply(env, mean) # 计算env环境空间中所有变量的均值$a[1] 5.5$b[1] 4.535125$logic[1] 0.5 应用及拓展应用展示原始数据为按年份year、地区loc和商品类别type进行统计的销售量。我们要制作两个销售总量的crosstable，一个以年份为行、地区为列，一个以年份为行，类别为列。应用1-tapply实现crosstable功能12345678910111213141516171819202122232425262728293031&gt; df &lt;- data.frame(year=kronecker(2001:2003, rep(1,4)), loc=c('beijing','beijing','shanghai','shanghai'), type=rep(c('A','B'),6), sale=rep(1:12))&gt; df year loc type sale1 2001 beijing A 12 2001 beijing B 23 2001 shanghai A 34 2001 shanghai B 45 2002 beijing A 56 2002 beijing B 67 2002 shanghai A 78 2002 shanghai B 89 2003 beijing A 910 2003 beijing B 1011 2003 shanghai A 1112 2003 shanghai B 12&gt; tapply(df$sale, df[,c('year','loc')], sum) locyear beijing shanghai 2001 3 7 2002 11 15 2003 19 23&gt; tapply(df$sale, df[,c('year','type')], sum) typeyear A B 2001 4 6 2002 12 14 2003 20 22 应用2-mapply使两个嵌套列表对应项相加1234567891011121314151617181920212223242526272829&gt; list1 &lt;- list(a=1:5, b=list(c=1:4, d=5:9))&gt; list1$a[1] 1 2 3 4 5$b$b$c[1] 1 2 3 4$b$d[1] 5 6 7 8 9&gt; list2 &lt;- list(a=1:5, b=list(c=5:8, d=1:5))&gt; list2$a[1] 1 2 3 4 5$b$b$c[1] 5 6 7 8$b$d[1] 1 2 3 4 5&gt; "%+%" &lt;- function(x,y) mapply("+", x, y)&gt; mapply("%+%", list1, list2)$a[1] 2 4 6 8 10$b$b$c[1] 6 8 10 12$b$d[1] 6 8 10 12 14 相关函数byby-函数定义：by可以当成data.frame上的tapply，在数据框行上施用索引分组运算1by(data, INDICES, FUN, ..., simplify = TRUE) 参数列表：data: 数据框INDICES：与数据框行数等长的用于分组的索引FUN：要使用的函数 举例阐释 eg-by对数据框进行按行索引分组计算1234567891011121314151617181920212223242526&gt; data &lt;- data.frame(a=c(1:5), b=c(6:10))&gt; data a b1 1 62 2 73 3 84 4 95 5 10&gt; INDICES &lt;- c(1,1,2,2,2)&gt; by(data, INDICES, colMeans)INDICES: 1 a b 1.5 6.5 -------------------------------------------------------------------------------INDICES: 2a b 4 9 &gt; by(data, INDICES, rowMeans)INDICES: 1 1 2 3.5 4.5 -------------------------------------------------------------------------------INDICES: 2 3 4 5 5.5 6.5 7.5 outerouter-函数定义：作用于数组的类似于矩阵外积运算方式的运算函数1outer(X, Y, FUN = "*", ...) 参数列表：X、Y: 向量、数组FUN：当为空时即为外积运算，否则为将FUN代替外积运算符进行类似外积的运算操作 举例阐释 eg-outer的使用123456789101112131415161718192021222324252627&gt; x &lt;- 1:4; y &lt;- 2:4&gt; x; y[1] 1 2 3 4[1] 2 3 4&gt; outer(x, y) [,1] [,2] [,3][1,] 2 3 4[2,] 4 6 8[3,] 6 9 12[4,] 8 12 16&gt; month.abb [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"&gt; outer(month.abb, 1999:2003, FUN = "paste") [,1] [,2] [,3] [,4] [,5] [1,] "Jan 1999" "Jan 2000" "Jan 2001" "Jan 2002" "Jan 2003" [2,] "Feb 1999" "Feb 2000" "Feb 2001" "Feb 2002" "Feb 2003" [3,] "Mar 1999" "Mar 2000" "Mar 2001" "Mar 2002" "Mar 2003" [4,] "Apr 1999" "Apr 2000" "Apr 2001" "Apr 2002" "Apr 2003" [5,] "May 1999" "May 2000" "May 2001" "May 2002" "May 2003" [6,] "Jun 1999" "Jun 2000" "Jun 2001" "Jun 2002" "Jun 2003" [7,] "Jul 1999" "Jul 2000" "Jul 2001" "Jul 2002" "Jul 2003" [8,] "Aug 1999" "Aug 2000" "Aug 2001" "Aug 2002" "Aug 2003" [9,] "Sep 1999" "Sep 2000" "Sep 2001" "Sep 2002" "Sep 2003"[10,] "Oct 1999" "Oct 2000" "Oct 2001" "Oct 2002" "Oct 2003"[11,] "Nov 1999" "Nov 2000" "Nov 2001" "Nov 2002" "Nov 2003"[12,] "Dec 1999" "Dec 2000" "Dec 2001" "Dec 2002" "Dec 2003" sweepsweep-函数定义：对数组、矩阵按维度进行运算1sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...) 参数列表：x: 数组、矩阵MARGIN：运算维度，1表示行，2表示列，3即第三维度，以此类推STATS：运算参数，类似于减法中的减数，除法中的除数FUN：要使用的函数 举例阐释 eg1-对数组按行运算123456789101112&gt; mat &lt;- matrix(1:9, 3)&gt; mat [,1] [,2] [,3][1,] 1 4 7[2,] 2 5 8[3,] 3 6 9&gt; sweep(mat, 1, c(1,4,7), "+") # 第一行都加1，第二行都加4，第三行都加7 [,1] [,2] [,3][1,] 2 5 8[2,] 6 9 12[3,] 10 13 16 eg2-STATS可为其他格式，但注意与取MARGIN后的X结构相符1234567891011121314151617181920212223242526272829303132333435&gt; A &lt;- array(1:24, dim = 4:2)&gt; median &lt;- apply(A, 1:2, median)&gt; A, , 1 [,1] [,2] [,3][1,] 1 5 9[2,] 2 6 10[3,] 3 7 11[4,] 4 8 12, , 2 [,1] [,2] [,3][1,] 13 17 21[2,] 14 18 22[3,] 15 19 23[4,] 16 20 24&gt; median [,1] [,2] [,3][1,] 7 11 15[2,] 8 12 16[3,] 9 13 17[4,] 10 14 18&gt; sweep(A, 1:2, median), , 1 [,1] [,2] [,3][1,] -6 -6 -6[2,] -6 -6 -6[3,] -6 -6 -6[4,] -6 -6 -6, , 2 [,1] [,2] [,3][1,] 6 6 6[2,] 6 6 6[3,] 6 6 6[4,] 6 6 6 replicatereplicate-函数定义：rep能把输入参数重复数次，replicate则能调用表达式数次1replicate(n, expr, simplify = "array") 参数列表：n: 调用的次数expr：调用的表达式 举例阐释 eg-建立一个函数，模拟扔两个骰子的点数之和，然后重复运行10次123456&gt; game &lt;- function() &#123;+ n &lt;- sample(1:6,2,replace=T)+ return(sum(n))+ &#125;&gt; replicate(n=10, game()) [1] 6 6 6 7 7 7 11 8 7 9 aggregateaggregate-函数定义：可按要求把数据分组，然后对分组后的数据进行各种操作1aggregate(x, by, FUN, ...) 参数列表：x: 一种R数据结构，通常为数据框by：分组索引，必须为list格式FUN：要使用的函数 举例阐释 eg-按性别分组查看年龄和身高的均值1234567891011121314&gt; data &lt;- data.frame(name=c("张三","李四","王五","赵六"),+ sex=c("M","M","F","F"), age=c(20,40,22,30),+ height=c(166,170,150,155))&gt; data name sex age height1 张三 M 20 1662 李四 M 40 1703 王五 F 22 1504 赵六 F 30 155&gt; aggregate(data[,3:4], by=list(data$sex), mean) Group.1 age height1 F 26 152.52 M 30 168.0 致谢 参考文章 R语言apply函数族笔记 掌握R语言中的apply函数族 Dr. Feng Li-Personal Site]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>apply</tag>
        <tag>数据操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回归分析系列3-简单线性回归]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%973-%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[与大多数统计方法一样，回归也是一种简化数据的技术。回归分析利用变量间的简单函数关系，用自变量对困变量进行"预测"，使"预测值"尽可能地接近因变量的"观测值" 。 本节综述简单线性回归属于回归分析中最基础的一部分内容，仅仅涉及到两个变量之间的线性关系，但其作为学习多元回归乃至其他更复杂统计方法的基础，所以本节将先从理解”回归”这一概念人手，并讨论只有一个因变量和一个自变量的简单线性回归模型。 理解回归如何根据回归模型的构成形式理解回归模型的现实意义呢？在此，我们提出理解回归的三种视角： 1. 因果性：观测项 = 机制项 + 干扰项 2. 预测性：观测项 = 预测项 + 误差项 3. 描述性：观测项 = 概括项 + 残差项 这三种理解方式提供了定量分析的三种不同视角： 第一种方式接近于 古典计量经济学 的视角，这种方法试图找出具有决定性的模型并以此发现数据产生的机制。但当前更多的方法论研究者认为，所谓的”真实”模型并不存在，好的模型只是相对于其他模型而言更实用、更有意义或者更接近真实。 第二种方式适用于 工程学 领域，它通常用于在已知一组自变量和因变量之间的关系后，应用新的数据给出有用的预测回答。这一理解方法的特点是我们只是通过经验规律来做预测，而对因果关系的机制不感兴趣或不在乎。 第三种方式反映了当今 定量社会科学和统计学 的主流观点。它希望在不曲解数据的情况下利用模型概括数据的基本特征。这种方法与第一种方法的不同之处在于它并不关注模型是否”真实”，而只关注其是否符合已被观察到的事实。 在社会科学研究中，我们倾向于采用第三种视角，即统计模型的主要目标在于用最简单的结构和尽可能少的参数来概括大量数据所包含的主要信息。研究者需在精确性和简洁性之间进行权衡，从而找出最佳模型。 回归分析的步骤 问题的表述 变量的选择 - 专家论文、前人研究 数据的收集 模型设定 - 散点图、表达形式、基本假定 参数估计/模型拟合 - （加权）最小二乘法、极大似然法、岭估计法、主成分估计法 模型检验 - 假设检验、回归诊断 模型评价 - 拟合优度、交叉验证 解释预测 简单线性回归模型模型设定1—表达形式开门见山，写出数学表达式： y_i=\beta_0 + \beta_1 x_i + \epsilon_i 这里： Y 是一个随机变量； X 虽被称作变量，但它的各个取值其实是已知的，只是其取值在不同的个体之间变动； ε 是随机误差项，假定其为服从均值为 0、方差为 σ² 的正态分布的随机变量。 对应指定的 $x_i$ 值，在一定的条件下，对公式求条件期望后得到 总体回归方程： E(Y|X=x_i) = \mu_i = \beta_0 + \beta_1x_i它表示，对于每一个特定的取值 $x_i$，观测值 y 实际上都来自一个均值为 μ、方差为 σ² 的正态分布，回归直线将穿过点 $(x_i,\mu_i)$，$\beta_0$ 就是回归直线在 y 轴上的截距，而 $\beta_1$ 则是回归直线的斜率。如下图所示： 无论回归模型还是回归方程，都是针对总体而言，是对总体恃征的总结和描述。所以，参数 $\beta_0$ 和 $\beta_1$ 也是总体的特征。当利用样本统计量 $b_0$ 和 $b_1$ 代替总体回归方程中的 $\beta_0$ 和 $\beta_1$ 时，就得到了 估计的回归方程或经验回归方程，其形式为： \hat{y} = b_0 + b_1x_i同时，我们也可以得到观测值与估计值之差，称为残差，记作 $e_i$，它对应的是公式中的总体随机误差项 $\epsilon_i$，观测值、估计值和残差这三者之间的关系可用下图加以说明。 模型设定2—基本假定[诸多错误，日后修正]可以看到在第一步的模型设定中我们首先做出了线性假定方可建立线性回归模型，同时假定 ε 的分布以便于确定 $y_i$ 的分布，接下来着重阐释简单线性回归模型中的诸多假定及这些假定存在的必要性。 线性假定该假定规定 Y 的条件均值是自变量 X 的线性函数： E(Y|X=x_i)=\mu_i = \beta_0 + \beta_1 x_i 这里“线性”有双重含义，一方面可解释为变量 Y 和 X 之间是线性的，另一方面也可解释为回归函数关于参数是线性的。在某些情况下，我们可能会碰到非线性函数的情形。借助于数学上的恒等变换，我们有时可以将非线性函数转换成线性函数的形式。 例如，对于 $y_i = \alpha x_i^\gamma \sigma_i$，通过变换可以得到: \ln y_i = \beta_0 + \beta_1 \ln x_i + \epsilon_i其中， $\beta_0=\ln \alpha ,\beta_1=\gamma ,\epsilon_i=\ln\sigma_i$。经过转换后的方程便可以运用最小二乘法，并使得估计值仍然保持最小二乘法估计值的性质。 正交假定正交假定包括： 误差项 ε 和 x 不相关，即 $Cov(X,\epsilon)=0$ ; 误差项 ε 的期望值为0，即 $E(\epsilon)=0$ ;推导： 由正交假定可得 $Cov(\hat{y},\epsilon)=0$ 。 在线性假定和正交假定下，可以将简单线性回归方程中 y 的条件期望定义为: E(Y|x)=\beta_0 + \beta_1 x正交假定是一个关键的识别假定，它帮助我们从条件期望 E(Y|x) 中剥离出误差项。在这假定下，利用最小二乘估计得到的 β0 和 βl 的估计值 b0 和 b1 是无偏的[详见下方-各随机变量的分布]，即： \begin{align*} E(b_0)&=\beta_0 \\ & \\ E(b_1)&=\beta_1 \end{align*}这一假定是最小二乘估计的计算的理论依据，所以 最小二乘估计的结果一定无例外地满足如下公式: \begin{cases} &\sum_{i=1}^{n}e_i=0 \\ & \\ &\sum_{i=1}^{n}x_ie_i=0 \end{cases} \rightleftharpoons \begin{cases} & \frac{\partial D}{\partial b_0} = -2\sum_{i=1}^{n}(y_i-b_0-b_1x_i) = 0 \\ & \\ & \frac{\partial D}{\partial b_1} = -2\sum_{i=1}^{n}x_i(y_i-b_0-b_1x_i) = 0 \end{cases}独立同分布假定也称 i.i.d 假定，是指误差项 ε 相互独立，并且遵循同一分布，有： \begin{align*} \sigma_\epsilon^2 &= \sigma^2 \\ & \\ Cov(\epsilon_i,\epsilon_j)&=0,\left (i\neq j \right ) \end{align*} 尽管在没有 i. i. d 假定的情况下，最小二乘估计已经可以满足无偏性和一致性，但是同时满足前三个假定时，最小二乘估计值将是总体参数的"最佳线性无偏估计值"，也就是通常所说的BLUE (best linear unbiased estimator)。这里，"最佳"表示"最有效"，即抽样标准误最小。 正态分布假定尽管 i.i.d 假定规定误差项 ε 独立且同分布，但是它仍然无法确定 ε 的实际分布。不过，对于大样本数据，我们可以根据中心极限定理对 β 进行统计推断。然而在小样本情况下，我们只有在假定 ε 服从正态分布时才能使用 t检验 \epsilon_i \sim N(0,\sigma^2)此时，最小二乘估计与总体参数的最大似然估计(MLE) 结果一致(Lehmann &amp; CaseUa, 1998),也就是说 b0 和 b1 不仅是 β0 和 β1 的最佳线性无偏估计，而且是所有的 β0 和 β1 (线性和非线性的)无偏估计中的最佳选择。 之所以这么说是因为在所有无偏估计中，最大似然估计是最佳无偏估计值。需要注意的是，由于最大似然估计可以是非线性的，因此最大似然解释的有效性将比最小二乘解释的有效性更广。进一步讲，最大似然估计的统计推断在大样本情况下具有渐近性质。也就是说，当样本规模趋于无穷大时，最大似然估计不仅满足一致性(渐近无偏)，而且能够取得一致估计量中的最小方差。 参数估计—最小二乘估计回顾一下，前文建立的线性回归模型如下： y_i = \beta_0 + \beta_1x_i + \epsilon_i = E(y_i|x_i) + \epsilon_i = \mu_i + \epsilon_i在样本数据下得到拟合回归模型如下： y_i = b_0 + b_1x_i + e_i = \hat{y_i} + e_i各关系如图所示： 最小二乘估计的基本思路便是 找到一条与所有现有数据垂直距离平方和最小的直线，即确保观测值和预测值的残差平方和最小： D = \sum_{i=1}^{n}e_i^2 = \sum_{i=1}^{n}(y_i-\hat{y_i})^2 = \sum_{i=1}^{n}(y_i-b_0-b_1x_i)^2 注意是残差平方和而非误差平方和！！！ 这是因为当使用总体数据时得到的与所有观测点垂直距离平方和最小的直线便是总体回归线；当使用样本数据时得到的与所有观测点垂直距离平方和最小的直线只能是估计回归线。所以误差与总体回归线相匹配，残差与估计回归线相匹配，在样本数据下，我们得到的只能是估计回归线，最小二乘法中的"最小"也只能是"残差平方和最小"。 为使残差平方和达到最小值，有： \begin{cases} & \frac{\partial D}{\partial b_0} = -2\sum_{i=1}^{n}(y_i-b_0-b_1x_i) = 0 \\ & \\ & \frac{\partial D}{\partial b_1} = -2\sum_{i=1}^{n}x_i(y_i-b_0-b_1x_i) = 0 \end{cases}整理得正态方程组： \begin{cases} & nb_0 + b_1\sum_{i=1}^{n}x_i = \sum_{i=1}^{n}y_i \\ & \\ & b_0\sum_{i=1}^{n}x_i + b_1\sum_{i=1}^{n}x_i^2 = \sum_{i=1}^{n}x_iy_i \end{cases}求解得： \begin{align*} b_0 &= \frac{\sum x_i^2 \sum y_i - \sum x_i \sum x_iy_i}{n \sum x_i^2 - (\sum x_i)^2} \\ & \\ b_1 &= \frac{n \sum x_iy_i - \sum x_i \sum y_i}{n \sum x_i^2 - (\sum x_i)^2} \\ & \\ &= \frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sum (x_i - \bar{x})^2} \\ \end{align*}在实际计算时，我们通常使用下列两个化简后的式子： \begin{align*} b_1 &= \frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sum (x_i - \bar{x})^2} \\ & \\ &= \frac{\sum (x_i - \bar{x})(y_i - \bar{y})/(n-1)}{\sum (x_i - \bar{x})^2/(n-1)} \\ & \\ &= S_{xy}/S_x^2 \\ &\\ &= r\frac{S_y}{S_x} \\ & \\ b_0 &= \bar{y} - b_1\bar{x} \end{align*} 小结—各随机变量的分布在上面的运算中，我们接触到的随机变量有 $\epsilon$、$y_i$、$b_0$、$b_1$ 等，接下来我们对这些随机变量的分布做个总结。 $\epsilon$根据简单线性回归的假定前提可知：$\epsilon \sim N(0,\sigma^2)$ $y_i$由关系式 $y_i=\beta_0+\beta_1x_i+\epsilon_i$ 及 $\epsilon$ 的分布推知：$y_i \sim N(\beta_0+\beta_1x_i,\sigma^2)$ $b_0$ 、 $b_1$求解 $b_0$ 和 $b_1$ 的分布需要一些技巧，首先对 $b_0$ 和 $b_1$ 的表达式稍加变形： \begin{cases} b_0&=\frac{\sum x_i^2 \sum y_i - \sum x_i \sum x_iy_i}{n \sum x_i^2 - (\sum x_i)^2} \\ & \\ &=\sum \left [ \frac{1}{n}-\frac{(x_i-\bar{x})\bar{x}}{\sum (x_i-\bar{x})^2} \right ]y_i \\ & \\ b_1&=\frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sum (x_i - \bar{x})^2} \\ & \\ &=\sum \frac{x_i-\bar{x}}{\sum (x_i-\bar{x})^2}y_i \end{cases}可以看到，当 $x_i$ 确定，等式右端仅有 $y_i$ 为随机变量，并且现在 $y_i$ 的分布已知，$b_0$ 和 $b_1$ 的分布自然可以求出： 期望 \begin{align*} E(b_1)&= \sum \frac{x_i-\bar{x}}{\sum (x_i-\bar{x})^2} E(y_i) \\ & \\ &= \sum \frac{x_i-\bar{x}}{\sum (x_i-\bar{x})^2} (\beta_0+\beta_1x_i) \\ & \\ &= \sum \frac{x_i-\bar{x}}{\sum (x_i-\bar{x})^2} (\beta_0+\beta_1x_i) \leftarrow \beta_0=\bar{y}-\beta_1\bar{x} \bigstar \\ & \\ &= \frac{\sum \left [ (x_i-\bar{x})\bar{y}+\beta_1 (x_i-\bar{x})^2 \right ]}{\sum (x_i-\bar{x})^2} & \\ &= \beta_1 \end{align*} $\bigstar$：我们知道对样本数据有 $b_0=\bar{y}-b_1\bar{x}$，同时可推导出在总体数据中存在以下关系式： \begin{cases} &\beta_0 = y_i-\beta_1x_i-\epsilon_i \\ & \\ & \Rightarrow E(\beta_0)=E(y_i-\beta_1x_i-\epsilon_i) \\ & \\ &\Rightarrow \beta_0=E(y)-\beta_1E(x_i) \end{cases} 需要注意的是： 在第一个式子中，x 和 y 使用的是样本数据，得出的均值是样本均值； 在第二个式子中，x 和 y 使用的是总体数据，得出的期望是总体均值。 由于样本均值是总体均值的无偏估计，所以我们在推导 b1 的期望时使用的 β0 代换式是成立的。 再次应用这个性质 ——— 无偏估计，可以很容易的得到 $b_0$ 的期望： \begin{align*} E(b_0)&=E(\bar{y}-b_1\bar{x}) \\ & \\ &= E(y)-\beta_1E(x) \\ & \\ &= \beta_0 \end{align*} 方差 \begin{align*} Var(b_0)&= \sum \left \{ \left [ \frac{1}{n}-\frac{(x_i-\bar{x})\bar{x}} {\sum (x_i-\bar{x})^2} \right ]^2 Var(y_i) \right \} \\ & \\ &= \sigma^2 \sum \left [ \frac{1}{n}-\frac{(x_i-\bar{x})\bar{x}} {\sum (x_i-\bar{x})^2} \right ]^2 \\ & \\ &= \sigma^2 \sum \left [ \frac{1}{n^2}-\frac{(x_i-\bar{x})\bar{x}}{2n\sum (x_i-\bar{x})^2}+ \frac{(x_i-\bar{x})^2\bar{x}^2}{\sum (x_i-\bar{x})^2} \right ] \\ & \\ &= \sigma^2 \left [ \frac{1}{n}+\frac{\bar{x}^2}{\sum (x_i-\bar{x})^2} \right ] \\ & \\ & \\ Var(b_1)&= \sum \left \{ \left [ \frac{x_i-\bar{x}}{\sum (x_i-\bar{x})^2} \right ]^2 Var(y_i) \right \} \\ & \\ &= \sigma^2 \frac{\sum (x_i-\bar{x})^2}{[\sum (x_i-\bar{x})^2]^2} \\ & \\ &= \frac{\sigma^2}{\sum (x_i-\bar{x})^2} \end{align*} 可以看到在 $\epsilon$、$y_i$、$b_0$、$b_1$ 的分布中都有 $\sigma^2$ 的身影，但 $\sigma^2$ 目前还属于未知参数，所以接下来要做的就是构造 $\sigma^2$ 的估计量 $\hat{\sigma}^2$ 。 $\hat{\sigma}^2$由于 $\sigma^2$ 是总体中误差的方差，自然想到用样本中误差（即残差）的方差来做无偏估计： \hat{\sigma}^2 = \frac{\sum e_i^2}{n-2} = \frac{\sum (y_i-\hat{y_i})^2}{n-2} = \frac{SSE}{n-2}这里，$n-2$ 为总体误差方差的自由度。因为我们需要以回归直线为基准来计算 $e_i$ ( 即以 $y_i-\hat{y}_i$ 进行估计)，而决定这条直线需要估计截距和斜率两个参数，所以消耗了两个自由度。 模型检验—假设检验模型整体检验回归系数检验 模型评价—拟合优度 模型预测—响应值、响应均值 前景展望 需要提醒的是 OLS 回归方法找出的是两个变量间最佳的线性关系，但实际情况中两个变量间可能并不是简单的线性关系。因为社会现象往往受到诸多因素的共同影响，单因素造成某一社会现象的情况几乎不存在。但是，了解简单回归的原理是学习多元回归乃至其他更复杂统计方法的基础。 同时，在简单线性回归中除了最小二乘法还有多种进行参数估计的方法可以运用，其中最大似然法的思想其实是与最小二乘法相通的。 此外，尽管我们可以根据基本假定估计出回归模型，但是我们不知道这些假定是否成立。诊断数据仍然是必不可少的一个环节。这部分内容我们将在之后的系列 回归诊断 中进行详细讨论。 参考文章[1]谢宇著.回归分析[M].北京：社会科学文献出版社.2010.[2]（美）查特吉著.例解回归分析 原书第5版[M].北京：机械工业出版社.2013.]]></content>
      <categories>
        <category>回归分析</category>
      </categories>
      <tags>
        <tag>回归分析</tag>
        <tag>统计</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回归分析系列1-统计概念基础]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%971-%E7%BB%9F%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[尽管定量研究的结论建立在一定假设条件上，不一定具有普遍意义，但定量研究方法却是研究社会现象不可缺少的工具。这是因为，如果没有这种方法，我们就无法很好地捕捉和表述研究对象的变异性 本节综述本章着重介绍一些最基本的统计概念，比如总体、样本、随机变量、概率、期望、方差、标准差、协方差和相关系数等。这些概念着似简单，但却是线性回归方法的基础。只有真正熟练掌握并理解这些概念，才能在后面的学习中游刃有余。 概念掌握期望与条件期望 期望离散型： $E(X)=\sum_{i=1}^{n}x_{i}P(x_{i})$连续型： $E(X)=\int_{-\infty }^{+\infty}xf(x)dx$ 期望其实与均值类似，是个平均数，但两者之间的区别在于均值是根据某一变量的一系列已知取值求得的，因此，均值往往被特定地用来指称样本的一个特征，而期望代表的是整个总体的平均数、一个未知的总体参数，因此，它只是一个理论值。 条件期望离散型：$E(Y|X=x_{i})=\sum_{i=1}^{n}y_{i}p(Y=y_{i}|X=x_{i})$连续型：$E(Y|X)=\int yf_{Y|X}(y|x)dy$条件期望有以下性质： 2.1 若 X 与 Y 相互独立，则 $E(Y|X)=E(Y)$ 2.2 若 $k_{1}$,$k_{2}$ 为常数，则 $E[(k_{1}Y_{1}+k_{2}Y_{2})|X]=k_{1}E(Y_{1}|X)+k_{2}E(Y_{2}|X)$ 2.3 全期望公式/迭代期望法则 $E(Y)=E_{x}[E(Y|X)]$ 总体方差与样本方差 总体方差 \begin{align*} Var(X)&=\sum_{i=1}^{n}[x_{i}-E(X)]^{2}P(x_{i}) \\ & \\ &=E[X-E(X)]^{2} \\ & \\ &=E(X^{2})-[E(X)]^{2} \end{align*} 样本方差 S^{2}=\frac{1}{n-1}\sum_{i=1}^{n}(x_{i}-\bar{X})^{2} 总体标准差、样本标准差与标准误总体标准差：$\sigma (X)=\sqrt{Var(X)}$样本标准差：$S=\sqrt{S^{2}}$标准误：$S.E.=\sigma /\sqrt{n}$ 标准化随机变量z=\frac{X-E(X)}{\sigma (X)}在多元线性回归中，由于不同自变量的测量单位通常并不一致，因而得到的回归系数通常也不能直接进行相对大小的比较。但如果我们对随机变量进行标准化，消除了变量各自测量单位的影响，得到的标准化回归系数之间就能够进行比较了。标准化经常被用来解决由于变量测量单位不同而导致的结果不可比的问题。 标准化以后的新变量变成了一个均值为0 、方差为1 的变量。 协方差与相关系数 总体协方差协方差用于测量两个随机变量之间的线性关系。注意，这里强调了 线性 这个词。 \begin{align*} Cov(X,Y)&=\sum_{i}\sum_{j}[x_{i}-E(X)][y_{i}-E(Y)]P(x_{i},y_{i}) \\ & \\ &=E\left \{[X-E(X)][Y-E(Y)] \right \} \\ & \\ &=E(XY)-E(X)E(Y) \end{align*}其实，方差是协方差的一个特例，也就是说，X 的方差就是X 与其自身的协方差。 总体相关系数 \rho (X,Y)=\frac{Cov(X,Y)}{\sigma (X)\sigma (Y)} 样本协方差 S_{yx}=\frac{\sum_{i=1}^{n}(x_{i}-\bar{x})(y_{i}-\bar{y})}{n-1} 样本相关系数 \begin{align*} S_{yx}&=\frac{\sum_{i=1}^{n}(x_{i}-\bar{x})(y_{i}-\bar{y})}{n-1} \\ & \\ &\xrightarrow[standardized]{z_{i}=\frac{y_{i}-\bar{y}}{S_{y}}} \\ & \\ r_{yx}&=\frac{1}{n-1}\sum_{i=1}^{n} (\frac{y_{i}-\bar(y)}{s_{y}}) (\frac{x_{i}-\bar(x)}{s_{x}}) \\ & \\ &= S_{yx}/S_yS_x \\ & \\ &=\frac{\sum_{i=1}^{n} (y_{i}-\bar(y)) (x_{i}-\bar(x))}{\sqrt{\sum_{i=1}^{n} (y_{i}-\bar(y))^2 (x_{i}-\bar(x))^2}} \end{align*}相关系数，即标准化协方差，消除了量纲的影响，所以相关系数之间可以直接进行比较，刻画了线性相关关系的强弱与方向。 性质掌握随机变量的和与差 如果X 和Y 是两个随机变量，那么X+Y 的期望与方差为:期望：$E(X+Y)=E(X)+E(Y)$方差：$Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)$作为特例，如果X 和Y 相互独立，并且都服从正态分布，它们的和将服从均值为μ1+μ2、方差为σ1²+σ2² 的正态分布。 如果X 和Y 是两个随机变量，那么X-Y 的期望与方差为：期望：$E(X-Y)=E(X)-E(Y)$方差：$Var(X-Y)=Var(X)+Var(Y)-2Cov(X,Y)$作为特例，如果X 和Y 相互独立，并且都服从正态分布，它们的差将服从均值为μ1-μ2、方差为σ1²+σ2² 的正态分布。 依此类推，如果 $T=X_1 +X_2 +…+X_s$ 是S 个独立随机变量的和，那么T 的期望与方差为:期望：$E(T)=\sum_{i=1}^{S}E(X_{i})$方差：$Var(T)=\sum_{i=1}^{S}Var(X_{i})$ 期望的简单代数运算性质E(a+bX)=a+bE(X)方差的简单代数运算性质Var(a+bX)=b^2Var(X)协方差的简单代数运算性质 $Cov(X,X)=Var(X)$ $Cov(X,Y)=Cov(Y,X)$ $Cov(C,Y)=0$，C 为任意常数 $Cov(X_{1}+X_{2},Y)=Cov(X_{1},Y)+Cov(X_{2},Y)$ $Cov(a+bX,c+dY)=bd[Cov(X,Y)]$再次强调，对于方差和协方差，其变化只涉及测度，而不涉及位置。 $\rho (a+bX,c+dY)=\rho (X,Y)$这个性质表明，无论是测度变化还是位置变化都不会影响相关系数。 下节引读由于个体异质性的存在，我们不能利用样本对总体中的个体进行任何推断，但是，概括性的总体特征——参数是相对稳定的，总体参数可以通过总体中的一个样本构建样本统计量来进行估计。然而，样本提供的信息是有限的。那么，接下来的问题就在于如何依据样本信息来认识所研究的总体。统计推断在这里扮演着关键角色。所谓统计推断，就是通过样本统计量来推断未知的总体参数。 参考文章[1]谢宇著.回归分析[M].北京：社会科学文献出版社.2010.]]></content>
      <categories>
        <category>回归分析</category>
      </categories>
      <tags>
        <tag>回归分析</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客文章写作样式]]></title>
    <url>%2F2018%2F01%2F27%2F2018-01-27-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学习了新知识，疏于记录便会淡忘，要用到时方悔当初；纸本与现有平台有其局限性，对于技术文档的展示有颇多限制，个人博客不失为一个好的选择——源于记录，善于书页。 使用文章模板创建新文章1$ hexo new [layout] &lt;title&gt; 有关创建新文章的命令以及默认文件名等说明在官方文档里说的已经很清楚了，在此不再赘述。 文章模板文件Front-matter关于文件最上方的参数，参见 Hexo 官方文档的 Front-matter 和 页面变量，以下是本人常用的 ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* ！！！！！！！！！！** 每一项的 : 后面均有一个空格** 且 : 为英文符号** ！！！！！！！！！！*/title:/* 文章标题，可以为中文 */date:/* 建立日期，如果自己手动添加，请按固定格式** 就算不写，页面每篇文章顶部的发表于……也能显示** 只要在主题配置文件中，配置了 created_at 就行** 那为什么还要自己加上？** 自定义文章发布的时间*/updated:/* 更新日期，其它与上面的建立日期类似** 不过在页面每篇文章顶部，是更新于……** 在主题配置文件中，是 updated_at*/categories:/* 分类，支持多级，比如：- technology- computer- computer-aided-art则为technology/computer/computer-aided-art（不适用于 layout: page）*/tags:/* 标签** 多个可以这样写[标签1,标签2,标签3]** （不适用于 layout: page）*/description:/* 文章的描述，在每篇文章标题下方显示** 并且作为网页的 description 元数据** 如果不写，则自动取 &lt;!-- more --&gt;** 之前的文字作为网页的 description 元数据*/keywords:/* 关键字，并且作为网页的 keywords 元数据** 如果不写，则自动取 tags 里的项** 作为网页的 keywords 元数据*/comments:/* 是否开启评论** 默认值是 true** 要关闭写 false*/layout:/* 页面布局，默认值是 post，默认值可以在** 站点配置文件中修改 default_layout** 另：404 页面可能用到，将其值改为 false*/sticky:/* 文章置顶** 此项只有参考教程配置好，否则请勿添加！*/password:/* 文章密码，此项只有参考教程：** http://shenzekun.cn/hexo的next主题个性化配置教程.html** 第 24 节，配置好，否则请勿添加！** 发现还是有 bug 的，就是右键在新标签中打开** 然后无论是否输入密码，都能看到内容*/ 我的模板文件文件位置：~/blog/scaffolds/post.md123456789101112131415161718192021222324252627282930---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: tags: copyright: password: ---&lt;center&gt;**&lt;/center&gt;&lt;br&gt;![](http://p31gihke0.bkt.clouddn.com/)&lt;!--more--&gt;## ------## ------##------## 致谢&gt; ### 参考文章&gt; * []() &lt;!--more--&gt;以上属于文章的摘要（封面），会在主页显示出来，可以看到本人文章的封面一般是一段居中倾斜文字配上一张图。 文章内标题请从二级标题（##）开始！Ps：此处虽然给了模板，但其实博客的写作很随性的，你可以自主搭配样式，怎么舒服怎么来，下面就来介绍一下该怎样写一篇博文以及如何增添样式来使文章逻辑分明，便于阅读与理解。（宝宝们放心，看懂了后写起来比Word省心多了） 使用 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，我们可以使用它： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 它的优点在于： 专注你的文字内容而不是排版样式 可读，直观。适合所有人的写作语言 轻松的导出 HTML、PDF 和本身的 .md 文件 纯文本内容，兼容所有的文本编辑器与字处理软件 GFM 简明语法网络上关于Markdown的语法说明有很多，大家可以去网上随便找一篇读一读了解个大概。在不同平台上也衍生出了多样化的独具特色的Markdown语法，它们大同小异但也确实各有不同，下面的这篇文章简单介绍了Hexo下使用的MarkDown——Github的GFM的基本语法与标准： HEXO下的Markdown语法(GFM)写博客 Markdown 高级语法能用Markdown 做的事情还有很多，列表、代码块、图表这些都不是问题： 制作一份待办事宜 [Todo 列表] [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 高亮一段代码 Python 源码展示1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 更多更详细的Markdown语法使用教程见： [Cmd Markdown 语法手册](http://suo.im/3Q8rcF) 与其他语言相兼容在 Markdown 书写的过程中，不仅可以使用简明的 Markdown 语法，还可以通过使用 LaTex 语法来书写数学公式，使用HTML 语法来调整布局与颜色等。但是本人在实践中发现，GFM 对 HTML 语法的兼容性非常好，因为最终它就是转为 html 格式发布的，但是对于 LaTex 语法的书写发布渲染有时会出现一些奇怪的问题，建议如果写学术文章还是选择更加合适的 Markdown 平台，毕竟 GFM 在此只是用来写博客的。 LaTex 语法在Markdown语体下使用LaTex语法一般来将目的很单纯，就是美化数学公式的书写，主要有两种用法。 行内公式书写LaTex 源码展示-行内公式1$E=mc^2$ 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 行间公式书写：LaTex 源码展示-行间公式123$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ \sum_{i=1}^n a_i=0f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2什么？不熟悉 LaTex 语法，不用害怕，试试这个[在线LaTex公式编辑器](http://www.codecogs.com/latex/eqneditor.php) HTML 与 CSS 语法熟悉语法的同志们可以尽情发挥，如果你不熟悉也没关系，记住以下这几种常用的也够用了。 分隔线和空行 123456/* 分隔线 */&lt;hr /&gt;/* 注意事项 6：在XHTML 中，&lt;hr&gt; 必须被正确地关闭，比如 &lt;hr /&gt; *//* 空行 */&lt;br /&gt;/* 注意事项同上 */ 居中和对齐方式 1234/* 居中 */&lt;center&gt;内容&lt;/center&gt;/* 右对齐 */&lt;div style="text-align:right"&gt;内容&lt;/div&gt; 字体大小和颜色 12&lt;font color="#xxxxxx" size="number"&gt;内容&lt;/font&gt;/* 详细请查看 http://www.w3school.com.cn/tags/tag_font.asp */ 例：我是居中的小红 插入音乐和视频音乐可以直接用 HTML 的标签，写法如下：嵌入歌曲标签1&lt;audio src="https://什么什么什么.mp3" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the audio tag.&lt;/audio&gt; 如果想直接用已有平台上的歌，事情也很好办，可以将歌曲外链嵌入页面，以云村为例：打开网易云音乐找到自己喜欢的音乐或个点，点击生成外链：然后根据自己的需要，加在blog/theme/next/layout/_layout.swig中或blog/theme/next/layout/_macro/sidebar.swig中，当然也可以直接放在文章中，比如用以下外链生成的效果见本文顶部。代码清单-云村歌单外链12&lt;!--网易云音乐链接--&gt;&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=320 src="//music.163.com/outchain/player?type=0&amp;id=2058497430&amp;auto=0&amp;height=430"&gt;&lt;/iframe&gt; 如果你还想要加上歌词就需要安装一个插件Aplayer，在这篇文章里有详细说明。由于我没有这种需求就不再赘述了。 视频一样的，可以直接用 HTML 的标签，写法如下：1&lt;video poster="https://封面图.jpg" src="https://什么什么什么.mp4" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the video tag.&lt;/video&gt; 当然还可以用插件完成更多的功能，上面那篇文章里也有介绍，想更进一步的可以去看看。 使用写作样式适当的使用下面的写作样式可以使文章的可读性增强，但读者不要为了追求华丽而使用过多的样式，那样反而会适得其反，博主认为使用样式应该本着少即是多、重点突出、一图胜千言的思想去使用，致力于增加文章的可读性。毕竟，着重于内容的写作，让思想更好得展现是我们最初的也是最终的愿望。这和我们用 Markdown 写文章是一样的道理，用 Markdown 而不是直接写 HTML 代码，就是为了将更多时间花在文字上。 主题自带样式FontAwesome自己配置过主题的博主们对FontAwesome这个网站应该都不会陌生，此网站类似于一个图标库，我们可以通过直接在文章中使用 html 和 css 代码来调用网站上的图标，下面给出一些简单的使用例子： 调用图表示例代码123&lt;i class="fa fa-apple"&gt;&lt;/i&gt; 来个小苹果&lt;i class="fa fa-apple fa-2x"&gt;&lt;/i&gt; 变大的苹果&lt;i class="fa fa-apple fa-spin fa-2x fa-fw"&gt;&lt;/i&gt; 会转的苹果 &lt;/i&gt; 来个小苹果 变大的苹果 会转的苹果 更多有趣调用请查看官网的[使用示例](http://fontawesome.io/examples/) 代码块高亮123​```language title url link-text你的代码​``` language：代码语言的名称，用来设置代码块颜色高亮，非必须； title：顶部左边的说明，非必须； url：顶部右边的超链接地址，非必须； link-text：超链接的名称，非必须。 这 4 项应该是根据空格来分隔，如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]。 代码块高亮的模式可以在主题配置文件中设置：文件位置：~/blog/themes/next/_config.yml12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 要颜色正确高亮，可以在站点配置文件中设置自动高亮：文件位置：~/blog/_config.yml123456highlight: enable: true line_number: true# 代码自动高亮- auto_detect: false+ auto_detect: true 红色-和绿色+的样式也是一种语言，叫diff，所以你只需在 [language] 写diff，然后在相应代码前面加上-和+就行了。不过默认的-是绿色，+是红色，与 Github 上相反，你可以自己更改，此处本人使用了博主reuixiy的设置：文件位置：~/blog/themes/next/source/css/_custom/custom.styl123456789101112131415161718// 文章```代码块diff样式pre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125;// 文章```代码块顶部样式.highlight figcaption &#123; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9;&#125;.highlight figcaption a &#123; color: rgb(80, 115, 184);&#125; . 关于代码块高亮的高级个性化，可以看 zhuzhuxia 的博文: [HEXO下的语法高亮拓展修改](http://suo.im/qRryw) 标签的使用「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。 例如，在标准 Markdown 语法中，Hexo 无法指定图片的大小。这种情景即可使用标签来解决。 Hexo 内置来许多标签来帮助写作者可以更快的书写， 完整的标签列表 可以参考 Hexo 官网。 另外，Hexo 也开放来接口给主题，使主题有可能提供给写作者更简便的写作方法。示例1 -文本居中标签使用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; Every interaction is both precious and an opportunity to delight. 示例2 -书中名言引用标签123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; 效果示例：Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake note 标签要使用此标签首先要在主题配置文件中修改以下配置：文件位置：~/blog/themes/next/_config.yml123456789# Note tag (bs-callout).note: # 风格 style: flat # 要不要图标 icons: true # 圆角矩形 border_radius: 3 light_bg_offset: 0 下面展示 note 标签的使用，这些标签本文在上文已多次使用：1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info no-icon"&gt;&lt;p&gt;关于 note 标签的更多形式可以查看[这个页面](https://github.com/iissnan/hexo-theme-next/pull/1697)，介绍多多，自行选用&lt;/p&gt;&lt;/div&gt; 关于 note 标签的更多形式可以查看[这个页面](https://github.com/iissnan/hexo-theme-next/pull/1697)，介绍多多，自行选用 label 标签首先在主题配置文件中修改配置如下：文件位置：~/blog/themes/next/_config.yml123# Label tag.- label: false+ label: true 效果如下（@ 前面的是label的名字，后面的是要显示的文字）：default1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; 目前此标签有个 bug，如果把它加在一段文字的段首，则会有点问题，详见 [issue](https://github.com/iissnan/hexo-theme-next/issues/2022) 页面。 tabs 标签老规矩，先改主题配置文件：文件位置：~/blog/themes/next/_config.yml1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 0 先来个小示例：tans 标签示例1234567891011&#123;% tabs First unique name %&#125;&lt;!-- tab 我是孙行者--&gt;**我是真的！**&lt;!-- endtab --&gt;&lt;!-- tab 吾乃者行孙--&gt;**我才是真的！**&lt;!-- endtab --&gt;&lt;!-- tab 行者孙是也--&gt;**我真的是真的！**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 我是孙行者吾乃者行孙行者孙是也我是真的！ 我才是真的！ 我真的是真的！ 这个选项卡其实妙用无穷，下面这篇文章对此有诸多说明，推荐一看： [Hexo Theme Next Test](https://almostover.ru/2016-01/hexo-theme-next-test/) 按钮按钮示例源码1&#123;% btn https://www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125; 效果：点击下载百度 关于按钮的更多使用也可以前往上面说到的这篇文章里去查看。 自定义样式如果你曾经像我一样跟随那些大佬博主们折腾过自己的博客主题，那么你一定明白所谓自定义样式，就是将 CSS 代码加到custom.styl中，如果你和我一样对这方面一窍不通可以在这里了解了解 CSS 中id和class的知识。 由于这方面我并不太了解就不多说什么了，推荐大家去看一个很少女心的博主千灵夙赋的这篇文章：外部样式表汇总 致谢刚建博客的前两天，看了好多博主的博客，感叹各位博主的创造力与审美，同时也偷偷模仿了几位博主的博客样式，虽说学的有些不伦不类，不过大概也不会有大的改动了，毕竟建博客的初衷是为了记录，版式的设计为的是营造舒心方便的创作环境。 接下来就要认真考虑写什么、怎么写的问题，于是就有了本篇博文的诞生，由于以前有使用 Rmarkdown 的经历，所以学起来倒也省了许多气力，目前来看上面的写作样式已经足以让我尽情展现了，在此特别感谢无私整合资源的各位博主们，接下来的日子里就是真正输出内容的时候了，会涉及R和Python的学习心得以及自己做的数据报告，还会有Kaggle的大神代码解析或其他的一些有的没的，要不要考虑加个书单页和观影页嗯？总之，明天又是美好的一天，加油！ 参考文章 外部样式表汇总 Hexo Theme Next Test Markdown - 简单的世界 Cmd Markdown 语法手册 HEXO下的语法高亮拓展修改 CSS中的class与id区别及用法 HEXO下的Markdown语法(GFM)写博客 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 个性化设置]]></title>
    <url>%2F2018%2F01%2F23%2F2018-01-23-Next%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NexT 拥有丰富而简单的主题配置，结合第三方服务，可以打造出属于自己的博客,实现个性化定制。掌握F12的用法之后，每个窗口的任意地方都可以任你修改，开来体验这些功能吧！ Next 的官方文档介绍了为站点添加诸多功能的基本方式，这些方式大多通过修改主题配置文件 _config.yml 来完成。在这篇文章中，假定读者已经成功使用 GitHub Pages + Hexo + Next 来配置站点，请确保您已经读过Next 官方的配置文档，那是一份很好的教程，如果对自己网站的配置一知半解，花上半个小时去把它读懂并付诸实践不失为明智的选择。 你可以访问 Next 的使用文档 了解如何为自己的网站添加各种功能 开篇点题在修饰站点过程中，身为一个处女座Boy 的本博主本着优雅、实用、便利修改的原则来查找一些资料，结果发现许多的建站者的建议看起来厉害无比，各种代码齐天飞，实践起来却太过麻烦，也不便于以后的修改，非常不人性化！！！ 于是，我花了一下午+一晚上的时间对照着 Next官方文档 将站点和主题下的配置文件 _config.yml 基本上看了一遍，结果发现，其实很多问题在配置文件中修改几个参数即可，完全不必大动刀戈自己挥手写代码，当然，有些功能确实是还没集成到官方文件中的，许多博主给出的解决方案也十分贴心友好。在这里本人将 官方配置里没讲到的和已经过时需要修改 的功能做一个总结，算是对官方文档的一个补充，也给自己做个备忘，主要涉及以下功能： [ ] 网站设置 [ ] 加载条 [ ] 网站底部访问量 [ ] 网站底部字数统计 [ ] 隐藏网页底部powered By Hexo / 强力驱动 [ ] 在右上角或者左上角实现fork me on github [ ] 互动设置 [ ] 点击爆炸效果 [ ] 点击出桃心效果 [ ] 自定义鼠标样式 [ ] 博文设置 [ ] 博文置顶 [ ] 博文压缩 [ ] 文章加密访问 [ ] 字数统计功能 [ ] 主页文章添加阴影效果 [ ] 修改文章内链接文本样式 [ ] 在文章底部增加版权信息 [ ] 修改文章底部的那个带#号的标签 [ ] 其他 [ ] 修改字体大小 [ ] 添加评论-Valine [ ] 修改打赏字体不闪动 网站设置加载条 实现效果图 实现方法修改主题配置文件 _config.yml将 pace: false改为 pace: true就行了，还可以换不同样式的加载条，如下图： 网站底部访问量 实现效果图 实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 代码清单：文件位置：~/themes/next/layout/_partials/footer.swig1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码:123&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站访客数&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id=busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt; 网站底部字数统计 实现效果图 实现方法在博客根目录下，右键git bash运行如下代码: 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 隐藏网页底部powered By Hexo / 强力驱动打开主题配置文件,将改为powered: true改为powered: false即可。 在右上角或者左上角实现fork me on github 实现效果图 实现方法在GitHub Ribbons或GitHub Corners挑选自己喜欢的样式，并复制代码。例如，复制以下代码： 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 互动设置点击出桃心效果 实现效果图 实现方法进入这个网址，然后将里面的代码copy一下，在路径/themes/next/source/js/src里新建love.js文件并将代码复制进去，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 点击爆炸效果 实现效果图 实现方法跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下：12# Fireworksfireworks: true 完! 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码:1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125; 其中url里面必须是ico图片,ico图片可以上传到网上（如七牛云图床），然后获取外链，复制到url里就行了。 博文设置博文置顶修改hero-generator-index插件，把文件node_modules/hexo-generator-index/lib/generator.js内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加top值，数值越大文章越靠前:12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 博文压缩在Markdown文件里要显示到主页的摘要后一行加上：1&lt;!--more--&gt; 如本文： 文章加密访问 实现效果图 实现方法打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码清单：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似格式： 字数统计功能 实现效果图 实现方法在根目录下右键git bash安装hexo-wordcount： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 主页文章添加阴影效果 实现效果图 实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章内链接文本样式 实现效果图 实现方法修改文件themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body是为了不影响标题，选择p是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 在文章底部增加版权信息 实现效果图 实现方法在目录next/layout/_macro/下添加my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import "my-post-copyright" 保存重新生成即可。 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new “你的内容”之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：） 修改文章底部的那个带#号的标签 实现效果图 实现方法修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 其他修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base =16px 添加评论-Valine在leancloud 官网注册账号并访问控制台随便创建一个应用，进入里面记下在设置-应用KEY下找到appid和appkey复制到下图位置，记得enable: true: 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 侧边栏推荐阅读打开主题配置文件修改成这样就行了(links里面写你想要的链接):1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 致谢有一些博主非常无私，不断为Hexo 添加着各种功能，官方也在不断地整合这些资源，不断推出新功能，让我们这些前端小白们也能简单的美化自己的小屋，虽然折腾了很久，但确实感到成就满满，这里表达由衷的感谢！在写这篇文章的时候我又发现了好多有趣的设置，如本文左下角的微信订阅、一键回顶部、分享功能等等，还有好多好多功能，待我日后慢慢道来！ 参考文章 Moorez:hexo的next主题个性化教程:打造炫酷网站 Hexo 官方文档 Next 官方文档 未完待续…………]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmd Markdown 使用说明]]></title>
    <url>%2F2018%2F01%2F23%2F2018-01-23-Cmd-Markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式LaTeXE=mc^23. 高亮一段代码code1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： &lt;/i&gt; 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿&lt;/i&gt; 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地&lt;/i&gt; 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： &lt;/i&gt; 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置&lt;/i&gt; 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 LaTeX. 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 &#8617; code. 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 &#8617;]]></content>
      <categories>
        <category>软件推荐</category>
      </categories>
      <tags>
        <tag>Cmd-Markdown</tag>
      </tags>
  </entry>
</search>
